{"pages":[],"posts":[{"title":"精益敏捷开发和SCRUM框架","text":"精益敏捷开发与传统开发精益敏捷软件开发特点 互动沟通多 可运行软件早 客户协作多 拥抱变化 传统软件开发的三大要素范围+时间+成本，不可变不灵活 精益敏捷软件开发的拓展适应性计划-&gt; 以质量和价值为中心-&gt; 多次迭代开发-&gt; 开发范围灵活可变 精益敏捷软件开发流程 形成产品概念 初期产品设计 业务、产品架构 迭代0 搭建测试、开发环境，编写迭代1需求 迭代1-&gt;迭代N PO：设计解决方案、准备故事、拆分故事 开发测试：详细设计(沟通)、开发、测试 快速开发出MVP(最小交付版本) 敏捷框架SCRUM3个角色 产品负责人(PO-Product Ower) 交付经理(DM-Delivery Manager) 团队(Agile Team)：包含开发、测试等 3个工件 产品待办清单(Product Backlog) 优先级、粗粒度(由细到粗) 迭代计划 团队决定的每个迭代的工作项 用户故事(User Story) Card-故事卡：精简一句话概述工作单元 3-5天可完成 As…I want…So that的形式 可拆分，如PO按业务，Team按技术等 技术故事：Team提出系统的非功能要求 Conversation-交流：PO、DM和Team交流得出的故事细节 Confirmation-验收标准：故事完成的标准 5个活动 迭代计划会：承诺工作 站会：沟通、汇报进度 迭代评审会与演示会：可视化项目 迭代回顾会 下迭代需求整理 5个价值观 承诺 专注 开放 尊重 勇气","link":"/2019/10/15/AgileDevOfScrum/"},{"title":"设计模式（一）概述","text":"基本要素 PatternName-名称：有助于理解、记忆、讨论该设计模式 Problem-问题：描述应用设计模式的环境 Solution-解决方案：描述设计模式的组成成分、相互关系、职责与协作方式 Consequence-效果：描述设计模式的应用效果和性能需求，包括时间、空间、灵活性、拓展性等问题 分类功能分类 创建型：如何创建对象，将对象的创建和使用分离 结构型：如何将类/对象按照布局组成更大的结构 行为型：类/对象之间如何相互写作完成大型任务，以及如何配分职责 范围分类 类模式：用于处理类与子类的关系，继承实现，静态关系 对象模式：用于处理对象与对象的关系，组合/聚合实现，动态关系 分类图 概述创建型模式 Factory Method-工厂方法 定义一个用于创建产品的接口，由子类决定生产什么产品 Singleton-单例 某类只能生成一个实例，并提供一个全局访问点供外部获取该实例，可拓展成有限多例模式 Prototype-原型 以一个对象为原型通过克隆复制出多个新实例 Abstract Factory-抽象工厂 提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品 Builder-建造者 将一个复杂对象分解成多个简单部分，根据不同需要分别创建，最后构成复杂对象 结构型模式 Adapter-适配器 将一个类的接口转换成客户希望的另一个接口，使得多个类可以通过该接口兼容工作 Proxy-代理 为对象提供代理，从而限制、增强或修改该对象的一些特性 Bridge-桥接 用组合代替继承关系分离抽象和实现，降低耦合度 Decorator-装饰 动态给对象增加额外的功能 Facade-外观 为多个复杂子系统提供一个一致的接口便于访问 Flyweight-享元 共享技术支持大量细粒度对象的复用 Composite-组合 将对象组合成树状结构，使用户对单个对象和组合对象具有一致的访问性 行为型模式 Template Method-模板方法 定义一个操作中的算法框架而特定步骤的实现放在子类实现 Interpreter-解释器 提供如何定义语言的文法和对语言句子解释的方法 Strategy-策略 封装一系列算法，并定义统一的算法接口使它们相互替换不会影响到使用算法的客户 Command-命令 将请求封装成对象，使发出请求和执行请求的职责分割 Chain of Responsibility-职责链 将请求在对象中链式传播直到被响应，降低对象之间的耦合 State-状态 对象在内部状态改变时会相应改变行为能力 Observer-观察者 在一对多的对象间，当一个对象发生改变会通知并影响到其他对象行为 Mediator-中介者 定义对象之间的中介对象简化交互过程，降低对象间的耦合度 Iterator-迭代器 提供一种顺序访问聚合对象数据的方法而不暴露对象的内部表示 Visitor-访问者 不改变集合元素的情况下，为一个集合中的每个元素提供多种访问方式 Memento-备忘录 不破坏封装的情况下，获取并保存一个对象的内部状态并可恢复 设计原则提高系统的可维护性、可拓展性、可复用性，增加开发效率 (Open Closed Principle,OCP)-开闭原则 软件实体应当对拓展开放，对修改关闭 (Liskov Substitution Principle,LSP)-里氏替换原则 继承必须确保超类所拥有的性质在子类仍然成立 核心：子类可以拓展父类的功能，但尽量不要改变(重写)父类的方法 (Dependence Inversion Principle,DIP)-依赖倒置原则 高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象 核心：面向接口编程替代面向实现编程，降低类间的耦合度 (Single Responsibility Principle,SRP)-单一职责原则 一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分 核心：控制类的粒度大小、将对象解耦、提高其内聚性 (Interface Segregation Principle,ISP)-接口隔离原则 客户端不应该被迫依赖于它不使用的方法，一个类对另一个类的依赖应该建立在最小的接口上 核心：接口尽量小，一个接口只有一个职责，降低类对接口的依赖性 (Law of Demeter,LoD)-迪米特法则(最少知识原则) 如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用 核心：对象除了访问成员对象、创建的对象、方法参数的对象外，不直接访问其他对象 (Composite Reuse Principle,CRP)-合成复用原则 软件复用时，组合/聚合等关联关系&gt;继承关系 核心：通过将对象声明成成员对象进行调用其功能达到复用","link":"/2019/10/08/DesignPattern1-概述/"},{"title":"设计模式（二）UML统一建模语言：可视化设计","text":"类图Class-类 类名：类的唯一标识 属性(成员变量)：[可见性]属性名:类型[=默认值] 可见性：public(+)/private(-)/protected(#)/friendly(~) 操作(成员方法)：[可见性]名称(参数列表)[:返回类型] Interface-接口包含抽象操作但不包含属性，不可被实例化只能被子类实现 关系图Dependency-依赖关系一个类的方法通过局部变量、参数或静态方法调用另一个类中的方法 表示：带箭头的虚线，指向被依赖的类 Association-关联关系一个类的成员变量是另一个类的对象，有单向、双向关联 表示：带箭头的实线或没有箭头的实线 Aggregation-聚合关系是强的一种关联关系，整体和部分，has-a的关系，一个类的成员对象是整体对象的一部分，但成员对象可以脱离整体对象而独立存在 表示：空心菱形实线，菱形指向整体对象 Composition-组合关系是强的一种聚合关系，整体和部分，contains-a的关系，一个类的成员对象是整体对象的一部分，但成员对象不能脱离整体对象而存在 表示：实心菱形实线，菱形指向整体对象 Generalization-泛化关系耦合度最大的关系，一般和特殊，父类和子类，is-a的关系，一个类(子类)继承了另一个类(父类) 表示：空心三角箭头实线，箭头从子类指向父类 Realization-实现关系接口和实现类之间的关系，实现类实现了接口中声明的所有抽象操作 表示：空心三角箭头虚线，箭头从实现类指向接口 总结","link":"/2019/10/08/DesignPattern2-UML/"},{"title":"设计模式（三）创建型模式","text":"设计模式分类图 Factory Method-工厂方法问题用户使用对象并不需要在意对象的生产细节 解决方案定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中 结构图 主要角色 Abstract Factory-抽象工厂：接口，定义创建产品的方法，调用者通过其方法访问具体工厂创建产品 Concrete Factory-具体工厂：类，实现抽象工厂接口，完成具体产品的创建 Abstract Product-抽象产品：接口，定义产品的规范，如产品特性和功能 Concrete Factory-具体产品：类，实现抽象产品接口，与具体工厂对应，由具体工厂创建 效果 优点 用户不需要在意对象的创建细节(类名、创建参数等)，只需要在意所需产品对应的具体工厂即可 开闭原则：系统加入新产品不需要修改现有的抽象类和实现类，只需要增加实现对应抽象类的具体工厂类和产品类即可 缺点 类数较多，增加系统的复杂度 Abstract Factory-抽象工厂问题工厂方法只能生产一类产品，不能生产一族产品 解决方案定义一个创建多种产品对象的工厂接口 结构图 效果 优点 客户端不依赖产品实例的创建细节和内部结构 可用于创建不同场景的对象，如不同操作系统的视窗构件(Button和Text构件在Windows和Linux中的实现不同) 缺点 产品族增加一个种类产品时，所有工厂类需要进行修改，不满足开闭原则 Singleton-单例问题某些类对象多次创建浪费系统资源、数据内容难以保持一致(成员属性值遗失) 解决方案保证单例类只有一个实例对象，该对象由单例类创建，并对外提供一个访问该对象的全局访问点 结构图 主要特点 构造函数私有化 存在静态全局访问实例对象方法 实现方式 懒汉式：类加载时没有生成单例，第一次调用getInstance()时才创建单例 Instance实例需要添加volatile关键字保证线程同步 getInstance()方法需要添加synchronized保证线程安全 饿汉式：类加载时就创建一个单例，线程安全 Instance=new Singleton() Instance前添加final关键字保证初始化后常量不变 效果 优点 节约系统资源，严格控制用户访问实例，实例数据一致 缺点 无抽象层，单例类较难拓展 垃圾回收机制重新实例化单例类则会遗失先前持有数据 Prototype-原型问题需要创建大量相同/相似的对象，构造函数创建较为繁琐并且浪费资源 解决方案将一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象 结构图 实现方式 Java对象的克隆：Java中的Object类提供的clone()方法，原型类需要实现Cloneable接口覆盖基类的clone()方法 implements Cloneable Objetc clone() throws CloneNotSupportedException{return (Realizetype)super.clone();} 浅克隆：克隆对象的基本数据类型的变量都会重新创建，而引用类型指向的还是原对象所指向的 深克隆：克隆对象基本数据类型还有引用类型，都是重新创建的 覆盖的clone()方法内除了调用基类的colne()方法克隆自身，克隆出的新对象还需要调用引用对象的clone()赋值给自身的成员引用对象 拓展 由于克隆对象可能成员方法的实现细节与原对象可能不同，因此可以增加原型管理器PrototypeManager 来保存多种实现同一接口的不同成员方法的克隆原型 效果 优点 简化对象创建过程，对于层级复杂、属性较多的对象可以提高对象生成效率 缺点 对象包含的所有对象都需要实现克隆方法，增加代码量，增加系统复杂度 Builder-建造者问题创建复杂对象的各个部分频繁变化，但复杂对象的组成部分是不变的 解决方案将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，即将产品不变的部分(产品的构造)和变化的部分(产品的组成部分)分离 结构图 构件流程 建造者Builder：选择具体建造者创造，具体建造者决定复杂对象的细节组成部分 指挥者Director：通过Builder创建指挥者，用于Product的构建(new)与组装(set) 复杂对象Product：通过Director.construct()生产得到产品 拓展 如果创建的产品种类只有一种，只需要一个具体的建造者，可以省略抽象建造者和指挥者角色，简化系统 效果 优点 用户不需要知道产品内部组成细节，使用相同的创建过程可创建不同部件的复杂对象 每个建造者相对独立，增加新的创建者无需修改原有代码，符合开闭原则 可以更加精细控制产品构建过程(Builder)，将复杂产品的构建分解在不同的方法中 缺点 复杂对象的组成部分必须相同，使用范围有限制 产品的内部变化复杂，会增加很多的建造者类，增加系统复杂度","link":"/2019/10/09/DesignPattern3-创建型模式/"},{"title":"设计模式（四）结构型模式","text":"设计模式分类图 Adapter-适配器问题某种具备业务功能的类/对象已经存在，但是与当前系统的接口规范不兼容 解决方案将类的接口转换成另外一个可以兼容当前系统的接口 结构图 类适配器 对象适配器 主要角色 Adaptee-适配者：与当前系统不兼容的类 ObjectAdapter-适配器：转换器，将当前系统不兼容的类转换成可以兼容当前系统的接口 Target-目标接口：能与当前系统兼容的接口 实现方式 类适配器：将一个类转换成另一个新接口类 C++：多重继承，ObjectAdapter同时继承Adaptee和Target接口 Java：继承+实现，ObjectAdapter继承Adaptee同时实现Target接口 对象适配器：将一个对象转换成另一个新接口类的对象 ObjectAdapter持有Adaptee实例，实现Target接口方法内对Adaptee实例的方法进行改进 效果 优点 适配器类不改变原有的类，符合开闭原则 目标类和现有类解耦，提高程序拓展性 缺点 类适配器更换实现的过程较为复杂，增加系统复杂度 Proxy-代理问题由于性能、安全等原因不能直接访问目标对象 解决方案为某个对象提供一个代理，并由这个代理对象控制对原对象的访问 结构图 主要角色 Subject-主题：真实主题中需要代理的方法 RealSubject-真实主题：被代理的对象，实现具体业务逻辑 Proxy-代理：可以访问、拓展、控制真实主题的方法，提供代理后的与真实主题相同接口的方法 实现 RealSubject和Proxy均实现同一Subject接口类的方法 Proxy内部含有RealSubject的对象引用 拓展 普通代理模式的实现缺点 一个目标对象需要一个自身的代理，不灵活 目标对象存在代理才可以存在，不灵活 动态代理：代理逻辑与业务逻辑相互独立，不侵入(引用)，没有耦合 AOP：动态代理的最好诠释 效果 优点 代理能够分离调用者和被调用者，降低系统耦合度 多类型代理可以控制目标对象的访问 远程代理：保护、隐藏目标对象的地 虚拟代理：用代理代替复杂的目标对象计算，只有真正需要目标对象处理时才实例化，减少系统消耗 安全代理：控制不同种类用户对目标对象的访问权限 消息代理：消息队列 缺点 用户请求变慢，增加系统复杂度 Bridge-桥接问题多个类具备多个维度的变化，如用继承，则x种颜色类和y种字体类的文字有x*y个子类，繁多且难以拓展 解决方案将抽象与实现分离，使它们可以独立变化，组合代替继承的方法 结构图 核心思想 面向接口编程：Abstraction通过持有Implementor引用对象来实现RefinedAbstraction实体类与Implementor接口实现类的多种组合 效果 优点 拓展性好，无论有多少接口实现类，均可通过一个类实现组合 缺点 设计前需要识别出独立变化的维度，即抽离出接口类 Decorator-装饰问题一些类需要在不改变其核心功能的情况下动态拓展功能 解决方案不改变现有对象结构的情况下，动态地给该对象增加一些职责 结构图 主要角色 Component：接口，定义需要装饰的方法 Concrete Component：实现Component接口的类，装饰方法的核心实现 Decorator：实现Component接口的类，包含具体Component实例，通过其子类拓展装饰方法 Concrete Decorator：Decorator子类，实现装饰方法 经典案例 Java I/O标准库的设计 InputStream、OutputStream、Reader、Writer的子类都是抽象装饰类 拓展 单Concrete Component类 可不用Component接口，Decorator直接继承 单Concrete Decorator类 可将Decorator与Concrete Decorator合并 效果 优点 添加职责的类不能生成子类，则可以使用装饰模式 装饰类添加的功能可以动态添加(装饰)、撤销(不装饰) 缺点 具体装饰类会增加系统复杂度 Facade-外观问题系统功能增加，子系统越来越多，用户对系统的访问越来越复杂，这时系统内部改变客户端也要随之改变，违背了开闭原则 解决方案定义一个高层接口，为多个复杂的子系统提供一个统一的访问接口 结构图 核心思想 Facade持有多个子系统的实例，用户通过创建Facade实例、调用Facade方法达到调用多个子系统实例方法的效果 拓展 增加或者移除子系统需要修改外观类，违背开闭员原则，可以通过引入外观接口，实现多个具体外观类，每个具体外观类持有不同的子系统实例来解决这个问题 效果 优点 降低子系统与客户端之间的耦合度，简化客户端的调用过程，便于子系统的拓展和维护 符合迪米特法则：子系统只需要将外部调用接口暴露，隐藏内部方法 缺点 不引入外观接口的情况下，新增子系统需要修改外观类或客户端代码，不符合开闭原则 Flyweight-享元问题系统中需要创建或存在大量相同或相似对象实例，耗费系统资源，降低系统性能 解决方案运用共享技术复用大量细粒度的对象，即使用共享池相同的对象只需要保存一份，通常与工厂模式一起使用 结构图 主要角色 FlyweightFactory-享元工厂：创建和管理享元实例 Flyweight-享元接口：规范享元类实现的方法，非享元对象以参数方式传入 Concrete Flyweight-具体享元类：实现享元接口的方法 Unshared Concrete Flyweight-非享元类：不共享的外部状态 实例 JAVA中的JDBC连接池 getConnection方法返回连接池中的一个数据库连接(享元) 拓展 单纯享元模式 系统中不存在非享元类 复合享元模式 一些具体享元类持有单纯享元对象 效果 优点 减少内存中的重复对象，降低系统内存使用，提升系统性能 缺点 需要拆解对象为享元类和非享元类，提升系统复杂度，并且读取享元模式会使系统运行时间变长 Composite-组合问题对象之间存在部分-整体的关系，对这些简单对象与复合对象的处理较难 解决方案将对象组合成树状的层次结构，是用户对单个对象和组合对象有一致的访问性 结构图 透明结构 节点接口包含所有管理子节点方法(add/remove/getChild)，因此对于叶子节点类需要注意空指针等安全异常 安全结构 节点接口不包含管理子节点方法，因此客户端调用需要区分叶子节点和分支节点，失去封装性 效果 优点 客户端一致使用单个对象和组合对象，简化调用流程 更容易在组合对象中加入单个对象，符合开闭原则 缺点 设计复杂，类之间的层次关系较复杂 不容易使用继承来增加节点的新功能","link":"/2019/10/09/DesignPattern4-结构型模式/"},{"title":"Java8(一)概况","text":"概述简要来说，Java8的改变在许多方面比Java历史上任何一次改变都深远，如 行为参数化，将代码传递给方法 多核并行有了更简单的新思路，不局限于线程池和并发集合 更简易的编程方式，如Stream API 接口的默认方法 函数式编程 Java8新概念流处理流是一系列数据项，程序可以从输入流中读取数据项，或者将数据项写入输出流，类似Unix操作流 1cat file1 file2 | tr \"[A-Z]\" \"[a-z]\" | sort | tail -3 基于流思想，Java8在java.util.stream中添加了Stream API将许多操作联结起来形成一条复杂的流处理流水线 流处理可以一次执行多个操作 流处理可以并行、多线程执行 行为参数化将代码作为参数传递给方法，Stream API就是构建在行为参数化思想上的 并行与共享的可变数据一般情况下，流处理为了同时对不同的输入安全地执行，因此不能访问共享的可变数据，而Java8可以通过流实现简单的并行处理，打破“不能有共享的可变数据”这一规则 Java8新功能方法引用将类的函数方法作为参数值传递给方法，与对象引用传递对象类似，方法引用传递的是代码，是行为参数化的一种体现 语法 ClassName::FunctionName 例子 12345678//Java8以前File[] hiddenFiles = new File(\".\").listFiles(new FileFilter() { public boolean accept(File file) { return file.isHidden(); }}); //方法引用File[] hiddenFiles = new File(\".\").listFiles(File::isHidden); Lambda-匿名函数将匿名函数方法作为参数值传递给方法，与方法引用类似，也是行为参数化的一种体现 语法 (Params) -&gt; CodeBlock 例子 1(Apple a) -&gt; a.getWeight() &gt;150 流相比于Collection API和Thread API，Stream API处理集合数据的方式更加简单、高效 迭代遍历方式(简单) Collection API采用外部迭代：使用for-each循环获取每个集合元素再处理 Stream API采用内部迭代：数据处理完全在库内进行 多线程并行处理方式(高效) Thread API采用synchronized关键字：避免线程同时访问并更新共享变量 Stream API采用并行流：将Collection转换为Stream进行并行处理再转换回Collection，由于流中的方法在执行时元素之间基本无互动(无可变的共享对象)因此可以保证线程安全 例子 12345678//Stream+Lambda顺序处理List&lt;Apple&gt; heavyApples = appleList.stream() .filter(E -&gt; E.getWeight()&gt;150) //内部迭代遍历处理集合数据 .collection(Collectors.toList); //Stream+Lambda并行处理List&lt;Apple&gt; heavyApples = appleList.parallelStream() //并行流处理 .filter(E -&gt; E.getWeight()&gt;150) .collection(Collectors.toList); 默认方法接口可以包含实现类没有提供实现的方法签名，这让接口更容易改进和扩充，而不会破坏接口现有的实现类代码 stream方法，在Java8以前，Collection&lt;T&gt;接口和其实现类均无此方法，若需要添加这个方法 Java8以前方式：在Collection接口添加stream方法的声明，并在其所有实现类(List/Set/Map/ArrayList等)均实现此方法 Java8采用默认方法：在Collection接口使用default关键字增加默认方法stream()即可，所有实现类均可调用 Optional&lt;T&gt;Optional&lt;T&gt;致力于避免NullPointerException，其中有明确的方法来处理值不存在的情况 小结","link":"/2019/11/03/Java8-1-概况/"},{"title":"设计模式（五）行为型模式","text":"设计模式分类图 Template Method-模板方法问题一个系统的某些步骤是固定的，另一些步骤的实现与具体的环境相关 解决方案定义一个操作中算法的框架，而将一些特定步骤的实现延迟到子类中 结构图 主要角色 AbstractClass-模板类：定义了固定步骤的模板方法和特定步骤的基本方法 ConcreteClass-具体子类：实现特定步骤的基本方法 拓展 模板类中的基本方法包括三大方法 抽象方法：特定子类实现的方法 具体方法：模板类实现的固定方法，子类可以继承或覆盖 钩子方法：子类可以重写达到控制父类行为的方法 效果 优点 封装了算法不变部分，拓展了算法可变部分，符合开闭原则 使用继承模板类的方式实现代码复用 缺点 每个基本方法的不同实现需要编写一个子类继承，若父类中的可变基本方法过多，会增加系统的复杂性 Interpreter-解释器问题多次重复出现的问题有一定的相似性和规律性 解决方案将问题归纳定义成一个语言的文法，并且建立一个解释器来解释该语言中的句子 结构图 主要角色 Abstract Expression-抽象表达式接口：定义解释器的解释行为 Terminal Expression-终结表达式：实现文法中与终结符有关的操作，每个终结符都对应一个具体的终结表达式 Nonterminal Expression-非终结表达式： 实现文法中与非终结符有关的操作，每条规则都对应一个具体的非终结表达式 Context-环境：包含解释器需要的数据或者公共的功能 效果 优点 易于通过继承等机制改变和拓展文法，符合开闭原则 缺点 复杂文法难以维护，执行效率低 Strategy-策略问题实现某种目标根据情况有多种方法可以选择 解决方案定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户 结构图 主要角色 Strategy-策略接口：公共接口，不同的算法以不同的方式实现这个接口 Concrete Strategy-具体策略：实现策略接口 Context-环境类：持有策略类引用，提供给客户端调用 拓展 存在很多策略时，可以通过策略工厂类管理同时管理多个策略 效果 优点 将选择使用哪种算法(环境类)的职责与算法实现(具体策略类)的职责分离开，符合单一职责原则 用户可以在不修改在原有系统基础上(客户端代码和环境类代码)选择或新增算法，符合开闭原则 缺点 客户端必须理解所有策略算法的区别，以便在恰当时机选择恰当的具体策略类 具体策略类过多，任何细小的变化都导致要新增一个策略类，提升系统复杂度 Command-命令问题方法请求者和方法实现者耦合度太高 解决方案将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开 结构图 拓展 可撤销(Undo)/可恢复(Redo)命令 命令模式+备忘录模式，可将命令对象存储起来 宏命令模式 命令模式+组合模式，宏命令包含一簇命令，执行时将递归调用所包含的所有命令 效果 优点 请求调用者与请求接收者解耦，通过命令类进行交互 随机请求/增加/删除命令类较方便实现，符合开闭原则 缺点 大量具体命令类增加系统复杂度 Chain of Responsibility-职责链问题一个请求有多个对象可以处理，但每个对象的处理条件或者权限不同，增加了处理难度 解决方案避免请求发送者与多个请求处理者耦合在一起，将多个请求处理者通过后者引用的方式传递请求，直到正确的请求处理者处理完成。 结构图 链表的实现方法 拓展 纯职责链 一个请求必须被某一个处理者处理完成 不纯的职责链 一个处理者可以处理请求的部分责任后将剩余的责任传递给下一个处理者，并且一个请求可以最终不被任何处理者处理 效果 优点 一个请求可以动态地由多个处理者处理，并且客户端不需要明确指定具体的请求处理者 不改变原有系统情况下可以添加新的处理者，符合开闭原则 每个处理者只需要负责自己的职责，符合单一职责原则 缺点 不能保证每个请求一定被处理 客户端需要建立职责链，需要保证职责链不循环调用性，增加客户端的复杂度 较长的职责链，请求处理设计多个对象，降低系统性能 State-状态问题一个对象的行为取决与它的状态(情况)，且其在运行时会根据状态改变行为 解决方案对有状态的对象，把状态变化对应的行为的复杂判断逻辑提取到不同的状态对象中 结构图 核心思想 Context调用方法是自身持有的具体State引用实例中的方法 拓展 共享状态 多个环境对象需要共享一组状态，则可以状态模式+享元模式 效果 优点 状态与行为分离，满足单一职责原则 程序容易拓展新的状态和转换，符合开闭原则 状态可以控制自身转化，对于具备复杂状态的对象有利于控制其行为过程 缺点 将状态抽象成类，增加系统复杂度 Observer-观察者问题一个对象的行为/状态发生改变会导致一个/多个其他对象的行为/状态发生改变 解决方案定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新，又称为发布-订阅(Publish-Subscribe)模式 结构图 核心思想 ConcreteSubject类通过notifyObserver方法通知所有ConcreteObserver调用自身的response方法更新自身的状态 拓展 Java实现 java.util.Observable：对应Subject类，用Vector向量用于保存要通知的观察者对象 java.util.Observer：对应Observer接口，其update方法用于更新自身状态 效果 优点 在目标与观察者之间建立一个抽象的耦合关系，降低系统耦合度 增加新的目标/观察者无需修改原有系统代码，目标与观察者之间不存在关联关系，符合开闭原则 缺点 目标与观察者之间的依赖关系没有完全接触，可能存在循环调用 观察者过多的情况下，通知机制影响程序效率 Mediator-中介者问题对象之间存在网状交互结构，耦合度很高，一个对象的行为会影响到所有关联的对象 解决方案定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互 结构图 核心思想 Colleague通过send发送请求需要调用其关联的中介者mediator.relay(this)将请求转发给除了自己的其他Colleague类(调用其receive方法接受请求) 拓展 单例中介者 不定义中介者接口，将具体中介对象实现为单例 Colleague类不持有中介者实例，而是在需要时直接通过Mediator.getMedium()获取调用 效果 优点 将对象一对多的关联关系转变为一对一的关系，降低对象耦合性，易于维护和拓展 缺点 Mediator包含大量不同Colleague的交互细节，可能导致Mediator的relay方法非常复杂难以维护 Iterator-迭代器问题遍历聚合对象中的所有元素，想分离聚合对象的创建和遍历过程，不暴露聚合对象的内部表示 解决方案提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示 结构图 核心思想 ConcreteAggregate调用getIterator时通过传入ConcreteAggregate.list来实例化ConcreteIterator迭代器 效果 优点 访问聚合对象无需暴露其内部组成 存储数据与遍历数据的职责分离，降低系统耦合度 支持自定义具体迭代器的遍历方式 面向接口编程，增加新的聚合类/迭代器类无需修改原有代码，符合封闭原则 遍历不同的聚合类提供统一的接口，封装性良好 缺点 设计易拓展、满足所有聚合类使用条件的迭代器难度较大 Visitor-访问者问题集合对象中存在多种不同的元素，每种元素根据访问者不同存在多种访问方式 解决方案将数据结构中的元素对象和元素操作分离封装成单独类，不改变数据结构的前提下为元素对象提供多种访问方式 结构图 核心思想 ObjectStructure持有包含元素的容器并提供访问元素的方式，Vistor接口申明访问每个具体元素的访问方法，Element接口申明访问者访问元素的方法 拓展 访问者+迭代器模式 ObjectStructure可以实现迭代器接口，使用迭代器遍历自身容器持有的元素 访问者+组合模式 元素对象如果包含组合对象，可以使用组合模式 效果 优点 增加新的访问操作即增加新的具体访问者，符合开闭原则 将有关元素对象的访问集中在一个访问者对象中，符合单一职责原则 缺点 增加新的元素类需要修改每个具体访问者的相应具体操作，违背开闭原则 访问者依赖于具体类而不是抽象类，违背依赖倒置原则 访问者可以调用每一个元素的操作，违背元素的封装性(迭代器模式可改善) Memento-备忘录问题用户误操作一个对象，想要撤销操作 解决方案不破坏封装性前提下，捕获对象的内部状态保存至对象外部，之后在需要时可以将对象恢复至原先保存的状态，也称作快照模式 结构图 主要角色 Originator-发起人：用于存储当前时刻对象的状态，提供createMemento(创建备忘录)和restoreMemento(恢复备忘录数据)的功能 Memento-备忘录：负责存储Originator的内部状态，在需要时将存储的内部状态提供给Originator Caretaker-管理员：对Memento进行管理，提供Memento的get/set方法 核心思想 Originator需要保存状态的时候调用Caretaker.setMemento(Originator.createMemento())，需要恢复状态的时候调用Originator.restoreMemento(Caretaker.getMemento()) 拓展 多状态备份 备忘录模式+原型模式，让Originator实现Cloneable接口可以自我备份，这样就可以删除备忘录 效果 优点 提供一种可恢复的机制，当用户需要时能够比较方便地将数据恢复到历史版本状态 发起人类不持有备忘录，所有信息保存在备忘录中由管理者进行管理，符合单一职责原则 缺点 资源消耗大，内部状态信息过多或者频繁快照会占用过多系统资源","link":"/2019/10/09/DesignPattern5-行为型模式/"},{"title":"Java8(二)行为参数化","text":"行为参数化将代码块作为参数传递给一个方法，是一种处理频繁变更需求的软件开发模式 演变历史方法的代码逻辑的实现方式 常量实现(写死) 单参数实现(需求变化需修改) 多参数实现(复杂、不灵活) 接口作为参数实现(行为参数化) 详解方法以接口作为参数，通过接口的实现类的方法实现代码逻辑，这种方式使方法的行为取决于接口对象传递的代码，即将方法的行为参数化 简化当方法将行为参数化后，每当有新的行为就需要增加新的接口实现类，还是十分繁琐 匿名类 简化声明和实例化类的过程，允许你同时声明并实例化一个类，并且不需要指定类名 但匿名类往往很笨重，占用许多代码空间，存在许多模板代码可以优化 Lambda表达式 优化了匿名类的模板代码，仅保留方法参数、代码块 样例代码-Comparator排序对集合进行排序，Java8中List自带的sort方法可以用Comparator接口对象进行行为参数化 123456789101112//java.util.Comparatorpublic interface Comparator&lt;T&gt;{ public int compare(T o1, T o2);}//行为参数化List.sort方法 inventory.sort(new Comparator&lt;User&gt;() { public int compare(User u1, User u2){ return u1.getWeight().compareTo(u2.getWeight()); } });//Lambda表达式优化UserList.sort((User u1, User u2) -&gt; u1.getWeight().compareTo(u2.getWeight())); 样例代码-Runnable执行代码块线程的执行代码块可以使用Runnable接口对象进行行为参数化 123456789101112// java.lang.Runnable public interface Runnable{ public void run(); } //行为参数化Thread的构建方法Thread t = new Thread(new Runnable() { public void run(){ System.out.println(\"Hello world\"); } }); //Lambda表达式优化Thread t = new Thread(() -&gt; System.out.println(\"Hello world\")); 样例代码-GUI事件处理GUI编程的响应代码块可以使用EventHandler接口对象进行行为参数化 123456789Button button = new Button(\"Send\"); //行为参数化Button.setOnAction方法button.setOnAction(new EventHandler&lt;ActionEvent&gt;() { public void handle(ActionEvent event) { label.setText(\"Sent!!\"); } }); //Lambda表达式优化button.setOnAction((ActionEvent event) -&gt; label.setText(\"Sent!!\")); Lambda表达式概述简洁地表示可传递的匿名函数，仅包含参数列表、函数主体、返回类型和可抛出的异常列表(可选) 简洁：优化省去匿名类的模板代码 传递：可作为参数传递给方法或存储在变量中 匿名：不需要方法名称和方法声明 函数：不像方法一样属于某个特定的类，但和方法一样有参数列表、函数主体、返回类型和可抛出的异常列表(可选) 基本语法 (parameters) -&gt; expression 或者 (parameters) -&gt; {statements; } 示例123456789101112131415//布尔表达式(Apple a) -&gt; a.getWeight() &gt; 150//创建对象() -&gt; new Apple(150)//消费对象(Apple a) -&gt; { System.out.println(\"Apple Weight:\"); System.out.println(a.getWeight());}//单对象选择/提取(String s) -&gt; s.length()//组合多对象(int a, int b) -&gt; a * b//比较两个对象(Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight()) 使用场景-函数式接口 定义 只定义了一个抽象方法的接口 场景 Lambda表达式可以直接以内联的形式为函数式接口的抽象方法提供实现，并把整个表达式作为函数式接口的实例 标记 @FunctionalInterface 示例 12345678910//函数式接口：java.lang.Runnablepublic interface Runnable{ void run(); } //行为参数化的方法public static void process(Runnable r){ r.run(); } //Lambda表达式为函数式接口的抽象方法提供实现process(() -&gt; System.out.println(\"Hello World\")); 检测格式-函数描述符 定义 函数式接口的抽象方法的签名 表达 (parameters) -&gt; returnType 用途 可用于检测Lambda表达式的使用是否正确 示例 1234567891011//Lambda正确示例public Callable&lt;String&gt; fetch() { return () -&gt; \"Tricky example ;-)\";} //fetch()的返回类型Callable&lt;String&gt;的函数描述符是()-&gt;String//Lambda表达式的函数描述符是()-&gt;String//Lambda错误示例Predicate&lt;Apple&gt; p = (Apple a) -&gt; a.getWeight(); //Predicate&lt;Apple&gt;的函数描述符是(Apple)-&gt;boolean//Lambda表达式的函数描述符是(Apple)-&gt;Integer Lambda表达式背后的原理 类型检查 Lambda表达式的返回类型是从对应函数式接口的抽象方法的返回值中推理得出，因此不需要显式指定 Lambda对应的函数式接口可有多个 由于许多函数式接口存在抽象方法返回泛型T，因此同一个Lambda表达式可以应用于多个函数式接口 类型推断 Java编辑器会从上下文推断出Lambda表达式对应的函数式接口的抽象方法的参数类型，因此Lambda表达式可以省略参数类型，如E -&gt; E.getLength() 局部变量 Lambda表达式允许访问显式声明为final的局部变量，这种模式易于Lambda表达式做到并行处理 函数式接口除了Java API中已经存在的Comparable/Runnable/Callable的函数式接口，Java8的java.util.function包中还引入了常用的函数式接口 原始类型特化泛型函数式接口由于其通用性使用了泛型，但泛型只能绑定到引用类型，Java中的装箱拆箱能将原始类型与引用类型相互转换，但在性能方面需付出代价，因为装箱(原始-&gt;引用)后的值需要更多的内存 因此针对专门的输入参数类型的函数式接口的都有原始类型特化的函数式接口，起到提高性能的作用 异常默认的函数式接口均不允许抛出受检异常(Checked Exception)，若需要抛出异常，有两种方法 自定义函数式接口，并声明受检异常 12345//自定义函数式接口@FunctionalInterface public interface BufferedReaderProcessor { String process(BufferedReader b) throws IOException; //声明受检异常} Lambda表达式中使用try-catch块，显式捕捉受检异常 1234567Function&lt;BufferedReader, String&gt; f = (BufferedReader b) -&gt; { try { return b.readLine(); } catch(IOException e) { throw new RuntimeException(e); } }; 方法引用调用仅涉及单一方法的Lambda表达式的快捷写法 语法 ClassName::MethodName 示例 类别 静态方法的方法引用 Lambda (args) -&gt; ClassName.staticMethod(args) 方法引用 ClassName::staticMethod 示例 1234//Lambda(String s) -&gt; Integer.parseInt(s)//方法引用Integer::parseInt 任意类型实例方法的方法引用 Lambda (args, rest) -&gt; args.instanceMethod(rest) 方法引用 ClassName::instanceMethod 示例 1234//Lambda(String s, int i) -&gt; s.substring(i)//方法引用String::substring 外部局部对象的实例方法的方法引用 Lambda (args) -&gt; expr.instanceMethod(args) 方法引用 expr::instanceMethod 示例 123456//外部局部对象Thread currentThread = Thread.currentThread();//Lambda() -&gt; currentThread.dumpStack() //方法引用currentThread::dumpStack 对象的构造函数的方法引用 对于无参、一个参数、两个参数的构造函数，均有默认的函数式接口有对应，因此均可以使用方法引用 123456//无参构造函数 Supplier接口Apple::new == () -&gt; new Apple()//一个参数的构造函数 Function接口Apple::new == (args0) -&gt; new Apple(args0)//两个参数的构造函数 BiFunction接口Apple::new == (args0, args1) -&gt; new Apple(args0, args1) 对于三个参数以上的构造函数，Java8并没有提供与构造函数引用的签名匹配的函数式接口，因此需要自定义编写 1234567//自定义三个参数的函数式接口 @FunctionalInterface public interface TriFunction&lt;T, U, V, R&gt;{ R apply(T t, U u, V v); } //方法引用TriFunction&lt;Integer, Integer, Integer, Color&gt; colorFactory = Color::new; Lambda表达式实践在实践中使用行为参数化、函数式接口、Lambda表达式、方法引用使代码更简洁灵活 示例代码123456public static String processFile() throws IOException { try (BufferedReader br = new BufferedReader(new FileReader(\"data.txt\"))) { return br.readLine(); } } 简化流程 行为参数化 示例代码仅能读取文件第一行，若是需求变更需要读取文件的前两行则需要修改源代码，因此我们考虑使用行为参数化来传递行为 函数式接口传递行为 根据示例代码，我们需要创建一个函数描述符为(BufferedReader) -&gt; String的函数式接口，并可以抛出IOException异常 Lambda表达式实例化函数式接口 使用Lambda表达式为函数式接口的抽象方法提供实现，可以根据需求灵活地重用processFile方法 方法引用简化Lambda表达式 使用方法引用优化Lambda表达式 1234567891011121314151617//函数式接口@FunctionalInterface public interface BufferedReaderProcessor { String process(BufferedReader b) throws IOException; } //行为参数化的示例代码public static String processFile(BufferedReaderProcessor p) throws IOException { try (BufferedReader br = new BufferedReader(new FileReader(\"data.txt\"))) { return p.process(br); //行为参数化 } }//Lambda实例化函数式接口，灵活使用方法String oneLine = processFile((BufferedReader br) -&gt; br.readLine()); String twoLines = processFile((BufferedReader br) -&gt; br.readLine() + br.readLine()); //方法引用简化特定的Lambda表达式String oneLine = processFile(BufferedReader::readLine); 复合Lambda表达式函数式接口可以提供默认方法将Lambda表达式复合成更高级的复杂的表达式 比较器复合 函数式接口Comparator&lt;T&gt;提供了默认方法reversed、thenComparing 逆序 1appleList.sort(comparing(Apple::getWeight).reversed()); 比较器链 1appleList.sort(comparing(Apple::getWeight).thenComparing(Apple::getCountry)); 谓词复合 函数式接口Predicate&lt;T&gt;提供默认方法negate、and、or 组合谓词 123Predicate&lt;Apple&gt; redAndHeavyAppleOrGreen = redApple .and(a -&gt; a.getWeight() &gt; 150) .or(a -&gt; \"green\".equals(a.getColor())); 函数复合 函数式接口Function&lt;T,T&gt;提供默认方法andThen、compose 转换流水线 1234Function&lt;String, String&gt; addHeader = Letter::addHeader; Function&lt;String, String&gt; transformationPipeline = addHeader .andThen(Letter::checkSpelling) .andThen(Letter::addFooter); 小结","link":"/2019/11/03/Java8-2-行为参数化/"},{"title":"RocketMQ的安装与使用","text":"RocketMQ安装 添加Maven依赖12345&lt;dependency&gt; &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt; &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt; &lt;version&gt;4.3.0&lt;/version&gt;&lt;/dependency&gt; 消息示例(Topic)消息生产者RocketMQ可通过三种方式发送消息 Reliable Synchronous-可靠同步，主要用于重要通知的业务场景，如SMS通知等 相关要点注意 setVipChannelEnabled(false)：不设置可能造成[org.apache.rocketmq.remoting.exception.RemotingTooMuchRequestException: sendDefaultImpl call timeout]异常，发送消息失败 Topic：需要提前配置好，不设置可能造成[org.apache.rocketmq.client.exception.MQClientException: No route info of this topic, TopicTest]异常，发送消息失败 发送多条消息不建议使用SendResult.getSendStatus()作为业务逻辑处理的判断依据，因为当消息发送成功并通过RPC回调到程序上下文中时，其状态还未返回，容易造成程序异常崩溃 12345678910111213141516//通过ProducerGroupName初始化消息生产者DefaultMQProducer producer = new DefaultMQProducer(\"RocketMqTest\");//设置MQ的NameSrv服务地址producer.setNamesrvAddr(\"100.75.186.165:4308\");//关闭VIP通道，避免发送消息失败producer.setVipChannelEnabled(false);//启动生产者实例producer.start();//创建消息对象，包括Topic、Tag、Key和传递的数据Message msg = new Message(\"TopicTest\", \"TagTest\", \"KeyTest\",data.getBytes(RemotingHelper.DEFAULT_CHARSET));//Reliable Synchronous方式发送消息到NameSrv下的某个broker实例并得到返回结果SendResult sendResult = producer.send(msg);//关闭生产者实例producer.shutdown();//返回消息的响应return sendResult; 发送消息后可以在RocketMQ控制台查看发送到消息队列的消息 发送消息的响应格式为 12345678910111213{ \"sendStatus\": \"SEND_OK\", \"msgId\": \"0AC85B0F4A0C18B4AAC2507EF13B0000\", \"messageQueue\": { \"topic\": \"TopicTest\", \"brokerName\": \"broker-b\", \"queueId\": 5 }, \"queueOffset\": 0, \"offsetMsgId\": \"644BBAA2000010D4000000000000FE71\", \"regionId\": \"DefaultRegion\", \"traceOn\": true} Reliable Asynchronous-可靠异步，主要用于时间敏感的业务场景 1234567891011121314151617DefaultMQProducer producer = new DefaultMQProducer(\"RocketMqProducerGroupTest\");producer.setNamesrvAddr(\"100.75.186.165:4308\");producer.setVipChannelEnabled(false);producer.setRetryTimesWhenSendAsyncFailed(1); //异步发送消息可设置失败重试次数producer.start();Message msg = new Message(\"TopicTest\", \"TagTest\", \"KeyTest\", data.getBytes(RemotingHelper.DEFAULT_CHARSET));producer.send(msg, new SendCallback() { //异步发送消息可设置回调函数 @Override public void onSuccess(SendResult sendResult) { //发送成功 System.out.printf(sendResult.getMsgId()); } @Override public void onException(Throwable e) { //发送异常 e.printStackTrace(); }});producer.shutdown(); 不知道为什么一直报错org.apache.rocketmq.client.exception.MQClientException: No route info of this topic, TopicTest，以后有时间解决 One-Way Transmission：单向传输，主要用于中等(Moderate)可靠性的传输场景，如日志收集等 1234567DefaultMQProducer producer = new DefaultMQProducer(\"RocketMqProducerGroupTest\");producer.setNamesrvAddr(\"100.75.186.165:4308\");producer.setVipChannelEnabled(false);producer.start();Message msg = new Message(\"TopicTest\", \"TagTest\", \"KeyTest\",data.getBytes(RemotingHelper.DEFAULT_CHARSET));producer.sendOneway(msg); //单向传输发送消息，无响应信息producer.shutdown(); 消息消费者 如果使用SpringBoot可以在消费者方法上加上@PostConstruct注解使类被初始化时会自动调用该方法 123456789101112131415161718192021222324252627//通过ConsumerGroupName初始化消息消费者DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(\"RocketMqConsumerGroupTest\");//设置MQ的NameSrv服务地址consumer.setNamesrvAddr(\"100.75.186.165:4308\");//关闭VIP通道consumer.setVipChannelEnabled(false);//消费消息方式 consumerGroup第一次启动 CONSUME_FROM_FIRST_OFFSET从消息队列头部消费consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);//广播模式消费消息consumer.setMessageModel(MessageModel.BROADCASTING);//设置订阅的Topicconsumer.subscribe(\"TopicTest\", \"*\");//注册监听consumer.registerMessageListener(new MessageListenerConcurrently() { //重写获取消息后的回调函数 @Override public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context) { //相关业务逻辑 System.out.printf(\"%s Receive New Messages: %s %n\", Thread.currentThread().getName(), msgs); //返回消费成功标识 return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; }});//启动消息消费者consumer.start();System.out.printf(\"Consumer Started.%n\"); MessageExt数据结构JSON化输出 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950{ \"queueId\": 11, \"flag\": 0, \"sysFlag\": 0, \"keys\": \"KeyTest\", \"delayTimeLevel\": 0, \"msgId\": \"0AC85B0F4A7C18B4AAC2509FEA880001\", \"body\": [68,97,116,97,32,70,114,111,109,32,80,114,111,100,117,99,101,114], \"waitStoreMsgOK\": true, \"bodyCRC\": 610674504, \"queueOffset\": 0, \"storeSize\": 196, \"bornHostString\": \"10.200.91.15\", \"bornTimestamp\": 1571211857544, \"reconsumeTimes\": 0, \"storeTimestamp\": 1571211857534, \"bornHostBytes\": { \"array\": \"CshbDwAA9j8=\", \"limit\": 8, \"position\": 0 }, \"bornHost\": { \"address\": \"10.200.91.15\", \"port\": 63039 }, \"tags\": \"TagTest\", \"preparedTransactionOffset\": 0, \"storeHostBytes\": { \"array\": \"ZEu6oQAAENQ=\", \"limit\": 8, \"position\": 0 }, \"bornHostNameString\": \"IQSZ-D0479.cmrh.com\", \"commitLogOffset\": 71597, \"topic\": \"TopicTest\", \"offsetMsgId\": \"644BBAA1000010D400000000000117AD\", \"storeHost\": { \"address\": \"100.75.186.161\", \"port\": 4308 }, \"properties\": { \"MIN_OFFSET\": \"0\", \"MAX_OFFSET\": \"1\", \"KEYS\": \"KeyTest\", \"CONSUME_START_TIME\": \"1571211857550\", \"UNIQ_KEY\": \"0AC85B0F4A7C18B4AAC2509FEA880001\", \"WAIT\": \"true\", \"TAGS\": \"TagTest\" }} ConsumeConcurrentlyContext数据结构JSON化输出 123456789{ \"ackIndex\": 2147483647, \"delayLevelWhenNextConsume\": 0, \"messageQueue\": { \"queueId\": 11, \"topic\": \"TopicTest\", \"brokerName\": \"broker-a\" }} 将消息中的内容解码输出 12//Data From Producernew String(MessageExtObject.getBody(), Charset.forName(RemotingHelper.DEFAULT_CHARSET)); 顺序消息(Queue)RocketMQ提供MessageQueue采用FIFO方式发送顺序消息，原理是通过指定QueueId 生产者：将部分需要顺序消费的消息发往同一个Topic下的同一个MessageQueue 消费者：按顺序消费同一个Topic下的同一个MessageQueue里的消息(同一个Topic的不同MessageQueue可以并发消费) 顺序消息生产者123456789Message msg = new Message(\"TopicTest\", \"TagTest\", \"KeyTest\",(data+i).getBytes(RemotingHelper.DEFAULT_CHARSET));SendResult sendResult = producer.send(msg, new MessageQueueSelector() { @Override public MessageQueue select(List&lt;MessageQueue&gt; mqs, Message msg, Object arg) { Integer id = (Integer) arg; int index = id % mqs.size(); //mqs.size()是该Topic下的queue数量 return mqs.get(index); //根据index标识该消息发送到的queue }}, 1); //这里的参数是select方法的arg参数 即同一批需要顺序消费的消息的Integer标识,如订单ID 顺序消息消费者1234567891011121314151617//设置线程数 保证同一个Topic下的同一个MessageQueue里的消息不被并发消费consumer.setConsumeThreadMin(1);consumer.setConsumeThreadMax(1);//并发消费//consumer.registerMessageListener(new MessageListenerConcurrently() {// @Override// public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context) {// return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;// }//});//顺序消费consumer.registerMessageListener(new MessageListenerOrderly() { @Override public ConsumeOrderlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context) { return ConsumeOrderlyStatus.SUCCESS; }}); 可以看到消息均发送到queueId为1的MessageQueue队列中被顺序消费 1234567891011121314151617Fetch Msg Topic : TopicTestFetch Msg brokerName : broker-aFetch Msg queueId : 1 //MessageQueueIdFetch Msg Body : Data From Producer0Fetch Msg Tags : TagTestFetch Msg Topic : TopicTestFetch Msg brokerName : broker-aFetch Msg queueId : 1 //MessageQueueIdFetch Msg Body : Data From Producer1Fetch Msg Tags : TagTestFetch Msg Topic : TopicTestFetch Msg brokerName : broker-aFetch Msg queueId : 1 //MessageQueueIdFetch Msg Body : Data From Producer2Fetch Msg Tags : TagTest MessageQuese概念创建Topic时可以指定该Topic的queue数量，如16 这里指定的Queue还会根据Broker数量对Topic进行分片，因此一个Topic下的queue数量为指定的QueueNum*BrokerNum 可以在RocketMQ控制台查看Topic下的MessageQueu情况 Spring Cloud Stream概述 Spring Cloud Stream 是一个用于构建基于消息的微服务应用框架 基于 SpringBoot来创建具有生产级别的单机 Spring 应用，并且使用 Spring Integration与 Broker 进行连接 特点提供了消息中间件配置的同一抽象，推出了 publish-subscribe、consumer groups、partition 这些统一的概念 Binder：跟外部消息中间件集成的组件，用来创建Binding Binding：在消息中间件与应用程序提供的Provider 和Consumer之间提供了一个桥梁，包括InputBinding和OutputBinding 实战代码 Maven依赖 123456&lt;!-- RocketMQ --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt; &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt; &lt;version&gt;4.3.0&lt;/version&gt;&lt;/dependency&gt; 配置文件 12345apache.rocketmq.nameservice.address=100.75.186.165:4308apache.rocketmq.producer.group=cmuop_appapache.rocketmq.consumer.group=cmuop_appapache.rocketmq.consumer.subscribe.topics=test-topicapache.rocketmq.consumer.subscribe.tags=* ProducerService 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566@Servicepublic class ProducerService { @Value(\"${apache.rocketmq.nameservice.address}\") private String rocketmqNamesrvAddr; @Value(\"${apache.rocketmq.producer.group}\") private String rocketmqProducerGroup; public ResponseData sendReliableMsg(String topic, String tag, String key, String Msg){ //通过ProducerGroupName初始化消息生产者 DefaultMQProducer producer = new DefaultMQProducer(rocketmqProducerGroup); //设置MQ的NameSrv服务地址 producer.setNamesrvAddr(rocketmqNamesrvAddr); //关闭VIP通道，防止消息发送错误 producer.setVipChannelEnabled(false); //启动生产者实例 try { producer.start(); } catch (MQClientException e) { e.printStackTrace(); } //创建消息对象，包括Topic、Tag、Key和传递的数据 //初始化返回值 SendResult sendResult=null; Message msg = null; try { msg = new Message(topic, tag, key,Msg.getBytes(RemotingHelper.DEFAULT_CHARSET)); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } //Reliable Synchronous方式发送消息到NameSrv下的某个broker实例并得到返回结果 try { sendResult= producer.send(msg); } catch (MQClientException e) { e.printStackTrace(); } catch (RemotingException e) { e.printStackTrace(); } catch (MQBrokerException e) { e.printStackTrace(); } catch (InterruptedException e) { e.printStackTrace(); } finally { //关闭生产者实例 producer.shutdown(); } //判断消息是否发送成功 if(Objects.nonNull(sendResult) || sendResult.getSendStatus().equals(SendStatus.SEND_OK)){ //消息发送成功 ResponseData&lt;Object&gt; responseData=new ResponseData&lt;&gt;(); responseData.setCode(\"1\"); responseData.setData(sendResult); return responseData; }else{ //消息发送失败 ResponseData&lt;Object&gt; responseData=new ResponseData&lt;&gt;(); responseData.setCode(\"0\"); responseData.setData(sendResult); return responseData; } }} ConsumerService 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/** * @author harvie * @version $Id: ConsumerService.java, v 0.1 2019-10-17 15:48 Exp $$ */@Servicepublic class ConsumerService { @Value(\"${apache.rocketmq.nameservice.address}\") private String rocketmqNamesrvAddr; @Value(\"${apache.rocketmq.consumer.group}\") private String rocketmqConsumerGroup; @Value(\"${apache.rocketmq.consumer.subscribe.topics}\") private String topics; @Value(\"${apache.rocketmq.consumer.subscribe.tags}\") private String tags; @PostConstruct public void asynConsumer(){ //通过ProducerGroupName初始化消息消费者 DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(rocketmqConsumerGroup); //设置MQ的NameSrv服务地址 consumer.setNamesrvAddr(rocketmqNamesrvAddr); //关闭VIP通道，防止消息发送错误 consumer.setVipChannelEnabled(false); //消费消息方式 consumerGroup第一次启动 CONSUME_FROM_FIRST_OFFSET从消息队列头部消费 consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET); //广播模式消费消息 consumer.setMessageModel(MessageModel.BROADCASTING); //设置订阅的Topic和Tag try { consumer.subscribe(topics, tags); } catch (MQClientException e) { e.printStackTrace(); } //设置消费类型 目前采取并发消费 //并发消费 设置监听处理器 consumer.registerMessageListener(new MessageListenerConcurrently() { @Override public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context) { return consumerMsg(msgs,context); } });// //顺序消费// //设置线程数 保证同一个Topic下的同一个MessageQueue里的消息不被并发消费// consumer.setConsumeThreadMin(1);// consumer.setConsumeThreadMax(1);// //设置监听处理器// consumer.registerMessageListener((MessageListenerOrderly) (msgs, context) -&gt; {// return ConsumeOrderlyStatus.SUCCESS;// }); //启动消费者实例 try { consumer.start(); } catch (MQClientException e) { e.printStackTrace(); } //可以优化成Log System.out.printf(\"Consumer Started.%n\"); } private ConsumeConcurrentlyStatus consumerMsg(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context){ System.out.println(\"consumeMsg Thread : \"+Thread.currentThread()); msgs.stream().forEach(E-&gt;{ System.out.println(\"Fetch Msg Topic : \"+context.getMessageQueue().getTopic()); System.out.println(\"Fetch Msg brokerName : \"+context.getMessageQueue().getBrokerName()); System.out.println(\"Fetch Msg queueId : \"+context.getMessageQueue().getQueueId()); System.out.println(\"Fetch Msg UniMsgId : \"+E.getMsgId()); System.out.println(\"Fetch Msg Body : \"+new String(E.getBody(), Charset.forName(RemotingHelper.DEFAULT_CHARSET))); System.out.println(\"Fetch Msg Tags : \"+E.getTags()); }); return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; }}","link":"/2019/11/03/RocketMQ/"},{"title":"Vue入门与实践(一) 概述","text":"Vue的架构设计MVVM(Model-View-ViewModel)：一种软件架构设计模式，思想是事件驱动编程，核心是通过ViewModel层向上与View层双向绑定、向下与Model层通过接口进行数据交互，实现View与Model层的解耦，而Vue.js就是MVVM中ViewModel层的实现者 通过Data Bindings观察Model中的数据变化并对View层对应数据进行更新 通过DOM Listeners监听View中的数据变化并通知Model层数据的改变 Vue.js的优点 轻量级、体积小，经过压缩后仅仅20+kb、 吸取了Angular(模块化)和React(虚拟DOM)的优点，并拥有自己的独特功能(计算属性等) 学习曲线平稳，开源，社区活跃度高 Vue两大核心概念 数据驱动+虚拟DOM：Vue通过Object.defineProperty将普通JS对象属性转换成getter/setter，在被访问/修改时能通知(Notify)关联的组件实例的watch对象在虚拟DOM上更新组件数据，当所有更新操作完成后再一次性将虚拟DOM上的修改更新到真实DOM上 组件化：页面上每个独立可交互的区域都可以视为一个组件，通过组件的复用，增强页面的拓展性和可维护性 Vue实例的生命周期主要的八大时期 beforeCreate：实例创建前，即数据观测(Data Observer)和event/watch事件配置前 created：实例创建完成后，即数据观测(Data Observer)、属性和方法的运算和event/watch事件的回调后，挂载前($el属性不可见) beforeMount：实例挂载前，相关的render函数被调用 mouted：实例挂载后调用 beforeUpdate：数据更新前调用，在虚拟DOM重新渲染和打补丁前 updated：数据更新后调用，虚拟DOM重新渲染和打补丁后，此阶段禁止更新数据状态(可能造成循环更新) beforeDestroy：实例销毁前，此时实例仍然可用 destroyed：实例销毁后，Vue实例的事件监听器、子实例等所有被销毁 Webpack 本质上是JS程序的静态模块打包器(module bundler)，递归地将程序需要的模块打包成一个或多个bundle 简洁地说，是前端资源模块化管理和打包的工具 可以将松耦合的模块按照依赖和规则打包成符合生产环境部署的前端资源 可以将按需加载的模块进行代码分离，等到实际需要时再异步加载 可以通过loader转换，任何形式的资源都可以当作模块，如CommonsJS、AMD、ES6、CSS、JSON、CoffeeScript、LESS等 JS模块管理规范：见JS模块化的演进","link":"/2019/09/23/Vue1-概述/"},{"title":"Vue入门与实践(二) Vue核心概念与官方脚手架介绍","text":"Vue组件的三大核心 computed-计算属性：用于将不经常变化的计算结果进行缓存，不像调用方法每次都要进行计算，计算属性只有关联的属性值变化且自身被调用时才进行计算，节约系统开销 slot-插槽：用于组件组合场景进行内容分发，父组件可以通过具名插槽分发数据给子组件不同的插槽，子组件也可以通过作用域插槽分发数据给父组件的插槽 methods-自定义事件：子组件可以通过自定义事件更改父组件中的Vue实例的数据，通过方法中执行this.$emit(“父组件方法名”,传递的参数)调用父组件中的方法更改Vue实例的数据 Vue-cliVue官方脚手架，用于快速生成vue项目模板 主要功能：统一目录结构，本地调试，热部署，单元测试，集成打包上线 项目目录结构 其中package.json中包含 scripts-封装vue常用命令 dependencies-生产环境依赖 devDependencies-开发环境依赖 src/main.js：项目入口文件 1234567891011//ES6写法，等同于require(\"vue\"),require是NodeJS提供的模块加载器import Vue from \"vue\";import App from \"./App\"; //上同，./表示当前目录 Vue.config.productionTip = false; //关闭浏览器关于环境的提示 new Vue({ el: \"#app\", //查找index.html中id为app的元素进行挂载 components: { App }, //声明引入组件App template: \"&lt;App/&gt;\" //模板，会将挂载元素替换为&lt;App/&gt;});","link":"/2019/09/23/Vue2-CLI/"},{"title":"Vue入门与实践(三) Vue-Router","text":"主要功能嵌套的路由/试图表，模块化基于组件的路由配置，基于Vue.js过度系统的视图效果，细粒度的导航控制，自动激活的CSS class链接 使用流程安装在项目根目录下执行 1npm install vue-router --save-dev 编写路由配置文件在src/router下创建index.js文件存放路由配置 12345678910111213141516171819202122import Vue from 'vue'// 导入路由插件import Router from 'vue-router'// 导入定义的组件import Component from '@/components/Component' // 安装路由Vue.use(Router); // 配置路由export default new Router({ routes: [ { // 路由路径 path: '/component', // 路由名称 name: 'Component', // 跳转到组件 component: Component } ]}); 加载配置文件在main.js下引入路由配置目录 12345678910111213import Vue from 'vue'import App from './App'// 导入上面创建的路由配置目录import router from './router' Vue.config.productionTip = false; new Vue({ el: '#app', router, // 配置路由 components: { App }, template: '&lt;App/&gt;'}); 使用路由在需要跳转的界面使用路由跳转 12345678910111213141516171819202122&lt;template&gt; &lt;div id=\"app\"&gt; &lt;img src=\"./assets/logo.png\" /&gt; &lt;!-- router-link默认被渲染成&lt;a&gt;标签 用于跳转 --&gt; &lt;router-link to=\"/\"&gt;首页&lt;/router-link&gt; &lt;router-link to=\"/content\"&gt;内容&lt;/router-link&gt; &lt;!-- router-view用于渲染路由匹配到的组件 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;HelloWorld&gt;&lt;/HelloWorld&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;import Content from \"./components/Content\"; //引入路由匹配的组件 export default { name: \"App\", components: { Content //声明路由匹配的组件 }};&lt;/script&gt; 路由实战：登录页面创建项目1vue init webpack vue-login 安装、配置路由依赖见上部分 安装Element-ui依赖项目根目录Npm安装依赖包 1npm i element-ui -S 项目中引入Element：在入口文件main.js写入 123456//引入Element-ui依赖import ElementUI from \"element-ui\";import \"element-ui/lib/theme-chalk/index.css\"; //安装Element-ui依赖Vue.use(ElementUI); 创建src/views用于存放页面编写views/Main.vue：登录成功的跳转页面 123456789101112&lt;template&gt; &lt;div&gt;首页&lt;/div&gt;&lt;/template&gt; &lt;script&gt;export default { name: \"Main\"};&lt;/script&gt; &lt;style scoped&gt;&lt;/style&gt; 编写views/Login.vue：登录页面 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;template&gt; &lt;div&gt; &lt;el-form ref=\"loginForm\" :model=\"form\" :rules=\"rules\" label-width=\"80px\" class=\"login-box\"&gt; &lt;h3 class=\"login-title\"&gt;欢迎登录&lt;/h3&gt; &lt;el-form-item label=\"账号\" prop=\"username\"&gt; &lt;el-input type=\"text\" placeholder=\"请输入账号\" v-model=\"form.username\" /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=\"密码\" prop=\"password\"&gt; &lt;el-input type=\"password\" placeholder=\"请输入密码\" v-model=\"form.password\" /&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button type=\"primary\" v-on:click=\"onSubmit('loginForm')\"&gt;登录&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;el-dialog title=\"温馨提示\" :visible.sync=\"dialogVisible\" width=\"30%\"&gt; &lt;span&gt;请输入账号和密码&lt;/span&gt; &lt;span slot=\"footer\" class=\"dialog-footer\"&gt; &lt;el-button type=\"primary\" @click=\"dialogVisible = false\"&gt;确 定&lt;/el-button&gt; &lt;/span&gt; &lt;/el-dialog&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;export default { name: \"Login\", data() { return { form: { username: \"\", password: \"\" }, // 表单验证，需要在 el-form-item 元素中增加 prop 属性 rules: { username: [ { required: true, message: \"账号不可为空\", trigger: \"blur\" } ], password: [{ required: true, message: \"密码不可为空\", trigger: \"blur\" }] }, // 对话框显示和隐藏 dialogVisible: false }; }, methods: { onSubmit(formName) { // 为表单绑定验证功能 this.$refs[formName].validate(valid =&gt; { if (valid) { // 使用 vue-router 路由到指定页面，该方式称之为编程式导航 this.$router.push(\"/main\"); } else { this.dialogVisible = true; return false; } }); } }};&lt;/script&gt; &lt;style scoped&gt;.login-box { border: 1px solid #dcdfe6; width: 350px; margin: 180px auto; padding: 35px 35px 15px 35px; border-radius: 5px; -webkit-border-radius: 5px; -moz-border-radius: 5px; box-shadow: 0 0 25px #909399;} .login-title { text-align: center; margin: 0 auto 40px auto; color: #303133;}&lt;/style&gt; 编写router/index.js配置路由跳转信息123456789101112131415161718192021222324252627282930import Vue from \"vue\";import Router from \"vue-router\";import HelloWorld from \"@/components/HelloWorld\";//引入所用的页面组件import Login from \"@/views/Login\";import Main from \"@/views/Main\"; Vue.use(Router); export default new Router({ routes: [ { path: \"/\", name: \"HelloWorld\", component: HelloWorld }, { // 登录页 path: \"/login\", name: \"Login\", component: Login }, { // 首页 path: \"/main\", name: \"Main\", component: Main } ]}); 在项目根目录运行项目1npm run dev 打开http://localhost:8080/#/login 没有输入账号/密码点击登录会弹出提示框 输入账号密码点击登录即可进入首页(Main.vue) 路由实战：首页导航栏多页面嵌套路由(子路由)要实现首页多页面(选项卡)，需要保证整个页面(首页)是一个路由，然后点击不同的选项卡展示不同的内容，即在首页这个路由中嵌套不同内容页面的子路由 编写子路由展示的页面编写views/user/Profile.vue 123456789101112&lt;template&gt; &lt;div&gt;个人信息&lt;/div&gt;&lt;/template&gt; &lt;script&gt;export default { name: \"UserProfile\"};&lt;/script&gt; &lt;style scoped&gt;&lt;/style&gt; 编写views/user/List.vue 123456789101112&lt;template&gt; &lt;div&gt;用户列表&lt;/div&gt;&lt;/template&gt; &lt;script&gt;export default { name: \"UserList\"};&lt;/script&gt; &lt;style scoped&gt;&lt;/style&gt; 修改router/index.js配置嵌套路由路径12345678910111213141516171819//引入嵌套的路由组件import UserProfile from \"@/views/user/Profile\";import UserList from \"@/views/user/List\";export default new Router({ routes: [ { // 首页 path: \"/main\", name: \"Main\", component: Main, //配置嵌套路由 children: [ { path: \"/user/profile\", component: UserProfile }, { path: \"/user/list\", component: UserList } ] } ]}); 修改views/Main.vue采用Element-Container布局容器组件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;template&gt; &lt;div&gt; &lt;!-- 布局容器 --&gt; &lt;el-container&gt; &lt;!-- 侧边栏容器 --&gt; &lt;el-aside width=\"200px\"&gt; &lt;el-menu :default-openeds=\"['1','2']\"&gt; &lt;el-submenu index=\"1\"&gt; &lt;template slot=\"title\"&gt; &lt;i class=\"el-icon-message\"&gt;&lt;/i&gt;用户中心 &lt;/template&gt; &lt;el-menu-item-group&gt; &lt;el-menu-item index=\"1-1\"&gt; &lt;!-- 配置嵌套路由跳转 --&gt; &lt;router-link to=\"/user/profile\"&gt;个人信息&lt;/router-link&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index=\"1-2\"&gt;演示&lt;/el-menu-item&gt; &lt;el-menu-item index=\"1-3\"&gt;演示&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;/el-submenu&gt; &lt;el-submenu index=\"2\"&gt; &lt;template slot=\"title\"&gt; &lt;i class=\"el-icon-caret-right\"&gt;&lt;/i&gt;用户管理 &lt;/template&gt; &lt;el-menu-item-group&gt; &lt;el-menu-item index=\"2-1\"&gt; &lt;!-- 配置嵌套路由跳转 --&gt; &lt;router-link to=\"/user/list\"&gt;用户列表&lt;/router-link&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index=\"2-2\"&gt;演示&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;/el-submenu&gt; &lt;/el-menu&gt; &lt;/el-aside&gt; &lt;!-- 侧边栏容器右边的外层容器 --&gt; &lt;el-container&gt; &lt;!-- 顶栏容器 --&gt; &lt;el-header style=\"text-align: right; font-size: 12px\"&gt; &lt;el-dropdown&gt; &lt;i class=\"el-icon-setting\" style=\"margin-right: 15px\"&gt;&lt;/i&gt; &lt;el-dropdown-menu slot=\"dropdown\"&gt; &lt;el-dropdown-item&gt;个人信息&lt;/el-dropdown-item&gt; &lt;el-dropdown-item&gt;退出登录&lt;/el-dropdown-item&gt; &lt;/el-dropdown-menu&gt; &lt;/el-dropdown&gt; &lt;span&gt;Harvie&lt;/span&gt; &lt;/el-header&gt; &lt;!-- 主要区域容器 --&gt; &lt;el-main&gt; &lt;!-- 渲染嵌套路由跳转的页面展示 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/el-main&gt; &lt;/el-container&gt; &lt;/el-container&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;export default { name: \"Main\"};&lt;/script&gt; &lt;style scoped&gt;.el-header { background-color: #b3c0d1; color: #333; line-height: 60px;} .el-aside { color: #333;}&lt;/style&gt; 运行展示 路由传参路径参数：通过路径传递参数，参数的值可显示在路由路径上修改路由配置：增加占位符标识 12345{ path: \"/user/profile/:id\", name: \"UserProfile\", component: UserProfile}, 传递参数：有两种方式 声明式导航：&lt;router-link&gt; 1&lt;router-link :to=\"{name:'UserProfile',params:{id:this.id}}\"&gt;声明式导航：个人信息&lt;/router-link&gt; 编程式导航：this.$router.push(path) 12345678&lt;el-menu-item index=\"1-2\" @click=\"userProfileClick\"&gt;编程式导航：个人信息&lt;/el-menu-item&gt;userProfileClick: function() { const id = this.$data.id; this.$router.push({ path: `/user/profile/${id}` });} 组件接收参数：$route.params.paramName 1this.$route.params.id 属性(Props)参数：通过props传递参数修改路由配置：添加开启props属性 123456{ path: \"/user/list\", name: \"UserList\", component: UserList, props: true} 传递参数：可传复杂对象 数据对象 12345678910111213data() { return { userInfo: { userName: \"harvie\", userPassword: \"wade777\", userHobby: [\"Basketball\", \"Football\", \"Game\"], userFriend: { userName: \"ryan\", userHobby: [\"Basketball\", \"Football\", \"Game\"] } } };} 声明式导航：&lt;router-link&gt; 1&lt;router-link :to=\"{name:'UserList',params:{userInfo:this.userInfo}}\"&gt;声明式导航：用户列表&lt;/router-link&gt; 编程式导航：this.$router.push(name,params) 12345678910&lt;el-menu-item index=\"2-2\" @click=\"userListClick\"&gt;编程式导航：用户列表&lt;/el-menu-item&gt;userListClick: function() { this.$router.push({ name: \"UserList\", params: { userInfo: this.$data.userInfo } });} 组件接收参数 12345props: { userInfo: { type: Object }} 重定向路由组件路由路径不同但是调用的组件相同 12345678src/router/index.js{ path: \"/goLogin\", redirect:\"/login\"}src/views/Main.vue&lt;router-link to=\"/goLogin\"&gt;回到登录&lt;/router-link&gt; 路由路径模式 hash：路径带#符号 history：路径不带#符号 配置方式 12345export default new Router({ mode: 'history', routes: [ ]}); 404-空页面路由配置路由1234567891011import NotFound from \"@/views/NotFound\"; export default new Router({ routes: [ //404页面 { path: \"*\", component: NotFound } ]}); 配置页面123456789101112&lt;template&gt; &lt;div&gt;页面不存在，请重试！&lt;/div&gt;&lt;/template&gt; &lt;script&gt;export default { name: \"NotFount\"};&lt;/script&gt; &lt;style scoped&gt;&lt;/style&gt; 路由钩子函数组件内的钩子函数beforeRouteEnter：导航进入路由对应的组件前调用，实例还没创建，不能使用this获取组件实例 beforeRouteUpdate：路由改变但是对应的组件被复用(如/user/1-&gt;/user/2)时被调用 beforeRouteLeave：导航离开组件的路由时被调用 参数(to,from,next) to：导航进入的路由的路径信息 from：导航离开的路由的路径信息 next：路由的控制参数 next()：进入下个页面 next(‘/path’)：改变路由跳转方向 next(false)：返回原来的路由 next((vm)=&gt;{})：beforeRouteEnter中获取访问组件实例(vm)的回调函数，在导航被确认时执行回调 实例1234567891011121314151617181920212223beforeRouteEnter: (to, from, next) =&gt; { next(vm =&gt; { // 通过 `vm` 访问组件实例 vm.getDate(); });},beforeRouteUpdate(to, from, next) { console.log(\"复用组件,to.params.id：\" + to.params.id); console.log(\"复用组件,from.params.id：\" + from.params.id); //这里的this是更新前的组件 console.log(\"复用组件,this.id：\" + this.id); next();},beforeRouteLeave(to, from, next) { const answer = window.confirm( \"Do you really want to leave? you have unsaved changes!\" ); if (answer) { next(); } else { next(false); }}","link":"/2019/09/23/Vue3-VueRouter/"},{"title":"Vue入门与实践(四) Vuex","text":"核心思想集中式存储、管理应用的所有组件的状态(数据)，并以相应的规则保证状态以一种可预测的方式发生变化 在vue-cli中安装、配置与基本使用安装1npm install vuex --save 配置在src/store/index.js编写配置文件 12345678910111213141516171819import Vue from \"vue\";import Vuex from \"vuex\";Vue.use(Vuex); const store = new Vuex.Store({ //store.state获取状态 state: { count: 0 }, mutations: { //store.commit('increment')触发状态变更 increment(state) { state.count++; }, decrement: state =&gt; state.count-- }}); export default store; 在src/main.js入口文件中在App上加载配置文件 123456789import store from \"./store\"; //引入配置文件 new Vue({ el: \"#app\", router, store, //加载配置文件 components: { App }, template: \"&lt;App/&gt;\"}); 在子组件中使用 123456789101112131415161718192021222324252627282930313233&lt;template&gt; &lt;div&gt; &lt;div&gt;计数器：{{count}}&lt;/div&gt; &lt;p&gt; &lt;button @click=\"increment\"&gt;+&lt;/button&gt; &lt;button @click=\"decrement\"&gt;-&lt;/button&gt; &lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { name: \"UserList\", computed: { count() { //this.$store获取状态数据 return this.$store.state.count; } }, methods: { increment() { //this.$store.commit(\"methodName\")触发状态数据变更 this.$store.commit(\"increment\"); },decrement() { //this.$store.commit(\"methodName\")触发状态数据变更 this.$store.commit(\"decrement\"); } }};&lt;/script&gt; &lt;style scoped&gt;&lt;/style&gt; 核心概念State单一状态树，用来保存全部状态 12345678910111213141516171819202122232425262728src/store/index.js-&gt;保存状态 state: { count: 0, userInfo: { userName: \"harvie\", userPassword: \"wade777\", userHobby: [\"Basketball\", \"Football\", \"Game\"], userFriend: { userName: \"ryan\", userHobby: [\"Basketball\", \"Football\", \"Game\"] } } }子组件获取(计算属性)import { mapState } from \"vuex\";...computed: { //计算属性直接获取 count() { return this.$store.state.count; }, //mapState插件快速获取 ...mapState({ userInfoFromSate: \"userInfo\", userNameFromState: state =&gt; state.userInfo.userName })} Getter状态的计算属性 1234567891011121314151617181920212223src/store/index.js state: { todos: [\"Basketball\", \"Football\", \"Game\", \"Program\"] }, getters: { todosOutSite: state =&gt; { return state.todos.filter(todo =&gt; todo.length &gt; 4); }, todosCount: state =&gt; { return state.todos.length; } }子组件使用import { mapGetters } from \"vuex\";...computed: { //获取store.getter状态计算属性 ...mapGetters({ todosOutSite: \"todosOutSite\", todosCount: \"todosCount\" })} Mutation更改state的方法，类似事件，可提交对象，需要遵循Vue的响应规则(初始化所需属性/对象添加新属性要使用Vue.set()方法)，必须是同步函数 12345678910111213141516171819202122src/store/index.jsstate: { userInfo: { userName: \"harvie\", userPassword: \"wade777\" }},mutations: { changeUserNameAndPassword(state, playload) { state.userInfo.userName = playload.userName; state.userInfo.userPassword = playload.userPassword; Vue.set(state.userInfo, \"userNameBak\", playload.userName); }}子组件使用onSubmit() { this.$store.commit(\"changeUserNameAndPassword\", { userName: this.form.name, userPassword: this.form.password });} Action可执行异步操作、分发(调用)多重mutation、并且action可以相互组合使用(Promise保证组合action的调用顺序) 12345678910111213141516171819202122232425262728src/store/index.jsactions: { //异步action actionA(context, playload) { //Promise保证异步操作完成后可回调 return new Promise((resolve, reject) =&gt; { //执行耗时的异步操作 setTimeout(() =&gt; { console.log(\"执行increment\"); context.commit(\"increment\", playload); resolve(); //回调函数 }, 5000); }); }, //组合action：actionA-&gt;actionB actionB(context, playload) { //Promise保证异步actionA-&gt;actionB的执行顺序 return context.dispatch(\"actionA\", playload).then(() =&gt; { console.log(\"执行decrement\"); context.commit(\"decrement\"); }); }}子组件使用countAction() { this.$store.dispatch(\"actionB\", { n: 100 });} Module单一状态树下所有状态集中在一个store对象比较复杂臃肿，因此可以将store分割成module，每个module拥有自己的state/mutation/action/getter/module 划分模块并引入 12345678910111213141516src/store/module/moduleName.jsexport default { state: {}, getters: {}, mutations: {}, actions: {}}src/store/index.jsimport PersonModule from \"./module/PersonModule\"; const store = new Vuex.Store({ modules: { person: PersonModule }}); 子组件调用模块：模块内部的state默认是局部的属于模块本身，但是模块内部的getters/mutations/actions默认是注册在全局命名空间的，因此子组件可以直接对名称相同的mutation/action进行同步调用，但是子组件调用state需要指定模块名称 123456789101112131415161718192021222324252627282930313233343536子组件调用state需要指明moduleNamecomputed: { count() { return this.$store.state.person.count; }, personName() { return this.$store.state.person.userInfo.userName; }, animalName() { return this.$store.state.animal.animalName; }, //mapState插件快速获取 ...mapState({ userInfoFromSate: state =&gt; state.person.userInfo, userNameFromState: state =&gt; state.person.userInfo.userName })}子组件调用getter/mutations/actions直接调用computed: { //调用getters ...mapGetters({ todosOutSite: \"todosOutSite\", todosCount: \"todosCount\" })},methods: { //调用mutations increment() { this.$store.commit(\"increment\", { n: 1 }); }, //调用actions countAction() { this.$store.dispatch(\"actionB\", { n: 100 }); }} 模块调用模块：由于模块内部state是局部的，getters(state,getters,rootState)/actions(state,commit,rootState)可以通过显示指定rootState参数访问根节点的state 命名空间：模块可以通过添加namespaced使其getter/action/mutation自动根据模块注册的路径调整命名 123456789101112131415161718192021222324模块开启命名空间export default { namespaced: true, // ...}子组件调用加上/模块名前缀computed: { //调用getters ...mapGetters({ todosOutSite: \"person/todosOutSite\", todosCount: \"person/todosCount\" })},methods: { //调用mutations increment() { this.$store.commit(\"person/increment\", { n: 1 }); }, //调用actions countAction() { this.$store.dispatch(\"person/actionB\", { n: 100 }); }} 命名空间的模块的action的全局注册与分发 12345678910111213141516171819action分发全局action/mutation：添加参数{root:true}export default { namespaced: true, // ... actions: { callAction(context,playload) { context.commit(\"mutationName\", playload, {root: true}); context.dispatch(\"actionName\",playload, {root: true}); } }}action注册全局：添加root:true并用handle方法处理逻辑actions: { actionName: { root: true, handler(namespacedContext, payload) {} // -&gt; 'someAction' }}","link":"/2019/09/23/Vue4-Vuex/"}],"tags":[{"name":"敏捷开发","slug":"敏捷开发","link":"/tags/敏捷开发/"},{"name":"SCRUM","slug":"SCRUM","link":"/tags/SCRUM/"},{"name":"开发模式","slug":"开发模式","link":"/tags/开发模式/"},{"name":"设计模式","slug":"设计模式","link":"/tags/设计模式/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Java8","slug":"Java8","link":"/tags/Java8/"},{"name":"RocketMQ","slug":"RocketMQ","link":"/tags/RocketMQ/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/tags/SpringBoot/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"前端","slug":"前端","link":"/tags/前端/"}],"categories":[]}