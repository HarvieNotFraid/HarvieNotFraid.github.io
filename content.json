{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/09/16/hello-world/"},{"title":"Vue入门与实践(一) 介绍Vue","text":"Vue的架构设计MVVM(Model-View-ViewModel)：一种软件架构设计模式，思想是事件驱动编程，核心是通过ViewModel层向上与View层双向绑定、向下与Model层通过接口进行数据交互，实现View与Model层的解耦，而Vue.js就是MVVM中ViewModel层的实现者 通过Data Bindings观察Model中的数据变化并对View层对应数据进行更新 通过DOM Listeners监听View中的数据变化并通知Model层数据的改变 Vue.js的优点 轻量级、体积小，经过压缩后仅仅20+kb、 吸取了Angular(模块化)和React(虚拟DOM)的优点，并拥有自己的独特功能(计算属性等) 学习曲线平稳，开源，社区活跃度高 Vue两大核心概念 数据驱动+虚拟DOM：Vue通过Object.defineProperty将普通JS对象属性转换成getter/setter，在被访问/修改时能通知(Notify)关联的组件实例的watch对象在虚拟DOM上更新组件数据，当所有更新操作完成后再一次性将虚拟DOM上的修改更新到真实DOM上 组件化：页面上每个独立可交互的区域都可以视为一个组件，通过组件的复用，增强页面的拓展性和可维护性 Vue实例的生命周期主要的八大时期 beforeCreate：实例创建前，即数据观测(Data Observer)和event/watch事件配置前 created：实例创建完成后，即数据观测(Data Observer)、属性和方法的运算和event/watch事件的回调后，挂载前($el属性不可见) beforeMount：实例挂载前，相关的render函数被调用 mouted：实例挂载后调用 beforeUpdate：数据更新前调用，在虚拟DOM重新渲染和打补丁前 updated：数据更新后调用，虚拟DOM重新渲染和打补丁后，此阶段禁止更新数据状态(可能造成循环更新) beforeDestroy：实例销毁前，此时实例仍然可用 destroyed：实例销毁后，Vue实例的事件监听器、子实例等所有被销毁 Webpack 本质上是JS程序的静态模块打包器(module bundler)，递归地将程序需要的模块打包成一个或多个bundle 简洁地说，是前端资源模块化管理和打包的工具 可以将松耦合的模块按照依赖和规则打包成符合生产环境部署的前端资源 可以将按需加载的模块进行代码分离，等到实际需要时再异步加载 可以通过loader转换，任何形式的资源都可以当作模块，如CommonsJS、AMD、ES6、CSS、JSON、CoffeeScript、LESS等 JS模块管理规范：见JS模块化的演进","link":"/2019/09/23/vue1/"},{"title":"Vue入门与实践(二) Vue核心概念与官方脚手架介绍","text":"Vue组件的三大核心 computed-计算属性：用于将不经常变化的计算结果进行缓存，不像调用方法每次都要进行计算，计算属性只有关联的属性值变化且自身被调用时才进行计算，节约系统开销 slot-插槽：用于组件组合场景进行内容分发，父组件可以通过具名插槽分发数据给子组件不同的插槽，子组件也可以通过作用域插槽分发数据给父组件的插槽 methods-自定义事件：子组件可以通过自定义事件更改父组件中的Vue实例的数据，通过方法中执行this.$emit(“父组件方法名”,传递的参数)调用父组件中的方法更改Vue实例的数据 Vue-cliVue官方脚手架，用于快速生成vue项目模板 主要功能：统一目录结构，本地调试，热部署，单元测试，集成打包上线 项目目录结构 其中package.json中包含 scripts-封装vue常用命令 dependencies-生产环境依赖 devDependencies-开发环境依赖 src/main.js：项目入口文件 1234567891011//ES6写法，等同于require(\"vue\"),require是NodeJS提供的模块加载器import Vue from \"vue\";import App from \"./App\"; //上同，./表示当前目录 Vue.config.productionTip = false; //关闭浏览器关于环境的提示 new Vue({ el: \"#app\", //查找index.html中id为app的元素进行挂载 components: { App }, //声明引入组件App template: \"&lt;App/&gt;\" //模板，会将挂载元素替换为&lt;App/&gt;});","link":"/2019/09/23/vue2/"},{"title":"Vue入门与实践(三) Vue-Router","text":"主要功能嵌套的路由/试图表，模块化基于组件的路由配置，基于Vue.js过度系统的视图效果，细粒度的导航控制，自动激活的CSS class链接 使用流程安装在项目根目录下执行 1npm install vue-router --save-dev 编写路由配置文件在src/router下创建index.js文件存放路由配置 12345678910111213141516171819202122import Vue from 'vue'// 导入路由插件import Router from 'vue-router'// 导入定义的组件import Component from '@/components/Component' // 安装路由Vue.use(Router); // 配置路由export default new Router({ routes: [ { // 路由路径 path: '/component', // 路由名称 name: 'Component', // 跳转到组件 component: Component } ]}); 加载配置文件在main.js下引入路由配置目录 12345678910111213import Vue from 'vue'import App from './App'// 导入上面创建的路由配置目录import router from './router' Vue.config.productionTip = false; new Vue({ el: '#app', router, // 配置路由 components: { App }, template: '&lt;App/&gt;'}); 使用路由在需要跳转的界面使用路由跳转 12345678910111213141516171819202122&lt;template&gt; &lt;div id=\"app\"&gt; &lt;img src=\"./assets/logo.png\" /&gt; &lt;!-- router-link默认被渲染成&lt;a&gt;标签 用于跳转 --&gt; &lt;router-link to=\"/\"&gt;首页&lt;/router-link&gt; &lt;router-link to=\"/content\"&gt;内容&lt;/router-link&gt; &lt;!-- router-view用于渲染路由匹配到的组件 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;HelloWorld&gt;&lt;/HelloWorld&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;import Content from \"./components/Content\"; //引入路由匹配的组件 export default { name: \"App\", components: { Content //声明路由匹配的组件 }};&lt;/script&gt; 路由实战：登录页面创建项目1vue init webpack vue-login 安装、配置路由依赖见上部分 安装Element-ui依赖项目根目录Npm安装依赖包 1npm i element-ui -S 项目中引入Element：在入口文件main.js写入 123456//引入Element-ui依赖import ElementUI from \"element-ui\";import \"element-ui/lib/theme-chalk/index.css\"; //安装Element-ui依赖Vue.use(ElementUI); 创建src/views用于存放页面编写views/Main.vue：登录成功的跳转页面 123456789101112&lt;template&gt; &lt;div&gt;首页&lt;/div&gt;&lt;/template&gt; &lt;script&gt;export default { name: \"Main\"};&lt;/script&gt; &lt;style scoped&gt;&lt;/style&gt; 编写views/Login.vue：登录页面 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;template&gt; &lt;div&gt; &lt;el-form ref=\"loginForm\" :model=\"form\" :rules=\"rules\" label-width=\"80px\" class=\"login-box\"&gt; &lt;h3 class=\"login-title\"&gt;欢迎登录&lt;/h3&gt; &lt;el-form-item label=\"账号\" prop=\"username\"&gt; &lt;el-input type=\"text\" placeholder=\"请输入账号\" v-model=\"form.username\" /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=\"密码\" prop=\"password\"&gt; &lt;el-input type=\"password\" placeholder=\"请输入密码\" v-model=\"form.password\" /&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button type=\"primary\" v-on:click=\"onSubmit('loginForm')\"&gt;登录&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;el-dialog title=\"温馨提示\" :visible.sync=\"dialogVisible\" width=\"30%\"&gt; &lt;span&gt;请输入账号和密码&lt;/span&gt; &lt;span slot=\"footer\" class=\"dialog-footer\"&gt; &lt;el-button type=\"primary\" @click=\"dialogVisible = false\"&gt;确 定&lt;/el-button&gt; &lt;/span&gt; &lt;/el-dialog&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;export default { name: \"Login\", data() { return { form: { username: \"\", password: \"\" }, // 表单验证，需要在 el-form-item 元素中增加 prop 属性 rules: { username: [ { required: true, message: \"账号不可为空\", trigger: \"blur\" } ], password: [{ required: true, message: \"密码不可为空\", trigger: \"blur\" }] }, // 对话框显示和隐藏 dialogVisible: false }; }, methods: { onSubmit(formName) { // 为表单绑定验证功能 this.$refs[formName].validate(valid =&gt; { if (valid) { // 使用 vue-router 路由到指定页面，该方式称之为编程式导航 this.$router.push(\"/main\"); } else { this.dialogVisible = true; return false; } }); } }};&lt;/script&gt; &lt;style scoped&gt;.login-box { border: 1px solid #dcdfe6; width: 350px; margin: 180px auto; padding: 35px 35px 15px 35px; border-radius: 5px; -webkit-border-radius: 5px; -moz-border-radius: 5px; box-shadow: 0 0 25px #909399;} .login-title { text-align: center; margin: 0 auto 40px auto; color: #303133;}&lt;/style&gt; 编写router/index.js配置路由跳转信息123456789101112131415161718192021222324252627282930import Vue from \"vue\";import Router from \"vue-router\";import HelloWorld from \"@/components/HelloWorld\";//引入所用的页面组件import Login from \"@/views/Login\";import Main from \"@/views/Main\"; Vue.use(Router); export default new Router({ routes: [ { path: \"/\", name: \"HelloWorld\", component: HelloWorld }, { // 登录页 path: \"/login\", name: \"Login\", component: Login }, { // 首页 path: \"/main\", name: \"Main\", component: Main } ]}); 在项目根目录运行项目1npm run dev 打开http://localhost:8080/#/login 没有输入账号/密码点击登录会弹出提示框 输入账号密码点击登录即可进入首页(Main.vue) 路由实战：首页导航栏多页面嵌套路由(子路由)要实现首页多页面(选项卡)，需要保证整个页面(首页)是一个路由，然后点击不同的选项卡展示不同的内容，即在首页这个路由中嵌套不同内容页面的子路由 编写子路由展示的页面编写views/user/Profile.vue 123456789101112&lt;template&gt; &lt;div&gt;个人信息&lt;/div&gt;&lt;/template&gt; &lt;script&gt;export default { name: \"UserProfile\"};&lt;/script&gt; &lt;style scoped&gt;&lt;/style&gt; 编写views/user/List.vue 123456789101112&lt;template&gt; &lt;div&gt;用户列表&lt;/div&gt;&lt;/template&gt; &lt;script&gt;export default { name: \"UserList\"};&lt;/script&gt; &lt;style scoped&gt;&lt;/style&gt; 修改router/index.js配置嵌套路由路径12345678910111213141516171819//引入嵌套的路由组件import UserProfile from \"@/views/user/Profile\";import UserList from \"@/views/user/List\";export default new Router({ routes: [ { // 首页 path: \"/main\", name: \"Main\", component: Main, //配置嵌套路由 children: [ { path: \"/user/profile\", component: UserProfile }, { path: \"/user/list\", component: UserList } ] } ]}); 修改views/Main.vue采用Element-Container布局容器组件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;template&gt; &lt;div&gt; &lt;!-- 布局容器 --&gt; &lt;el-container&gt; &lt;!-- 侧边栏容器 --&gt; &lt;el-aside width=\"200px\"&gt; &lt;el-menu :default-openeds=\"['1','2']\"&gt; &lt;el-submenu index=\"1\"&gt; &lt;template slot=\"title\"&gt; &lt;i class=\"el-icon-message\"&gt;&lt;/i&gt;用户中心 &lt;/template&gt; &lt;el-menu-item-group&gt; &lt;el-menu-item index=\"1-1\"&gt; &lt;!-- 配置嵌套路由跳转 --&gt; &lt;router-link to=\"/user/profile\"&gt;个人信息&lt;/router-link&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index=\"1-2\"&gt;演示&lt;/el-menu-item&gt; &lt;el-menu-item index=\"1-3\"&gt;演示&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;/el-submenu&gt; &lt;el-submenu index=\"2\"&gt; &lt;template slot=\"title\"&gt; &lt;i class=\"el-icon-caret-right\"&gt;&lt;/i&gt;用户管理 &lt;/template&gt; &lt;el-menu-item-group&gt; &lt;el-menu-item index=\"2-1\"&gt; &lt;!-- 配置嵌套路由跳转 --&gt; &lt;router-link to=\"/user/list\"&gt;用户列表&lt;/router-link&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index=\"2-2\"&gt;演示&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;/el-submenu&gt; &lt;/el-menu&gt; &lt;/el-aside&gt; &lt;!-- 侧边栏容器右边的外层容器 --&gt; &lt;el-container&gt; &lt;!-- 顶栏容器 --&gt; &lt;el-header style=\"text-align: right; font-size: 12px\"&gt; &lt;el-dropdown&gt; &lt;i class=\"el-icon-setting\" style=\"margin-right: 15px\"&gt;&lt;/i&gt; &lt;el-dropdown-menu slot=\"dropdown\"&gt; &lt;el-dropdown-item&gt;个人信息&lt;/el-dropdown-item&gt; &lt;el-dropdown-item&gt;退出登录&lt;/el-dropdown-item&gt; &lt;/el-dropdown-menu&gt; &lt;/el-dropdown&gt; &lt;span&gt;Harvie&lt;/span&gt; &lt;/el-header&gt; &lt;!-- 主要区域容器 --&gt; &lt;el-main&gt; &lt;!-- 渲染嵌套路由跳转的页面展示 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/el-main&gt; &lt;/el-container&gt; &lt;/el-container&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;export default { name: \"Main\"};&lt;/script&gt; &lt;style scoped&gt;.el-header { background-color: #b3c0d1; color: #333; line-height: 60px;} .el-aside { color: #333;}&lt;/style&gt; 运行展示 路由传参路径参数：通过路径传递参数，参数的值可显示在路由路径上修改路由配置：增加占位符标识 12345{ path: \"/user/profile/:id\", name: \"UserProfile\", component: UserProfile}, 传递参数：有两种方式 声明式导航：&lt;router-link&gt; 1&lt;router-link :to=\"{name:'UserProfile',params:{id:this.id}}\"&gt;声明式导航：个人信息&lt;/router-link&gt; 编程式导航：this.$router.push(path) 12345678&lt;el-menu-item index=\"1-2\" @click=\"userProfileClick\"&gt;编程式导航：个人信息&lt;/el-menu-item&gt;userProfileClick: function() { const id = this.$data.id; this.$router.push({ path: `/user/profile/${id}` });} 组件接收参数：$route.params.paramName 1this.$route.params.id 属性(Props)参数：通过props传递参数修改路由配置：添加开启props属性 123456{ path: \"/user/list\", name: \"UserList\", component: UserList, props: true} 传递参数：可传复杂对象 数据对象 12345678910111213data() { return { userInfo: { userName: \"harvie\", userPassword: \"wade777\", userHobby: [\"Basketball\", \"Football\", \"Game\"], userFriend: { userName: \"ryan\", userHobby: [\"Basketball\", \"Football\", \"Game\"] } } };} 声明式导航：&lt;router-link&gt; 1&lt;router-link :to=\"{name:'UserList',params:{userInfo:this.userInfo}}\"&gt;声明式导航：用户列表&lt;/router-link&gt; 编程式导航：this.$router.push(name,params) 12345678910&lt;el-menu-item index=\"2-2\" @click=\"userListClick\"&gt;编程式导航：用户列表&lt;/el-menu-item&gt;userListClick: function() { this.$router.push({ name: \"UserList\", params: { userInfo: this.$data.userInfo } });} 组件接收参数 12345props: { userInfo: { type: Object }} 重定向路由组件路由路径不同但是调用的组件相同 12345678src/router/index.js{ path: \"/goLogin\", redirect:\"/login\"}src/views/Main.vue&lt;router-link to=\"/goLogin\"&gt;回到登录&lt;/router-link&gt; 路由路径模式 hash：路径带#符号 history：路径不带#符号 配置方式 12345export default new Router({ mode: 'history', routes: [ ]}); 404-空页面路由配置路由1234567891011import NotFound from \"@/views/NotFound\"; export default new Router({ routes: [ //404页面 { path: \"*\", component: NotFound } ]}); 配置页面123456789101112&lt;template&gt; &lt;div&gt;页面不存在，请重试！&lt;/div&gt;&lt;/template&gt; &lt;script&gt;export default { name: \"NotFount\"};&lt;/script&gt; &lt;style scoped&gt;&lt;/style&gt; 路由钩子函数组件内的钩子函数beforeRouteEnter：导航进入路由对应的组件前调用，实例还没创建，不能使用this获取组件实例 beforeRouteUpdate：路由改变但是对应的组件被复用(如/user/1-&gt;/user/2)时被调用 beforeRouteLeave：导航离开组件的路由时被调用 参数(to,from,next) to：导航进入的路由的路径信息 from：导航离开的路由的路径信息 next：路由的控制参数 next()：进入下个页面 next(‘/path’)：改变路由跳转方向 next(false)：返回原来的路由 next((vm)=&gt;{})：beforeRouteEnter中获取访问组件实例(vm)的回调函数，在导航被确认时执行回调 实例1234567891011121314151617181920212223beforeRouteEnter: (to, from, next) =&gt; { next(vm =&gt; { // 通过 `vm` 访问组件实例 vm.getDate(); });},beforeRouteUpdate(to, from, next) { console.log(\"复用组件,to.params.id：\" + to.params.id); console.log(\"复用组件,from.params.id：\" + from.params.id); //这里的this是更新前的组件 console.log(\"复用组件,this.id：\" + this.id); next();},beforeRouteLeave(to, from, next) { const answer = window.confirm( \"Do you really want to leave? you have unsaved changes!\" ); if (answer) { next(); } else { next(false); }}","link":"/2019/09/23/vue3/"},{"title":"Vue入门与实践(四) Vuex","text":"核心思想集中式存储、管理应用的所有组件的状态(数据)，并以相应的规则保证状态以一种可预测的方式发生变化 在vue-cli中安装、配置与基本使用安装1npm install vuex --save 配置在src/store/index.js编写配置文件 12345678910111213141516171819import Vue from \"vue\";import Vuex from \"vuex\";Vue.use(Vuex); const store = new Vuex.Store({ //store.state获取状态 state: { count: 0 }, mutations: { //store.commit('increment')触发状态变更 increment(state) { state.count++; }, decrement: state =&gt; state.count-- }}); export default store; 在src/main.js入口文件中在App上加载配置文件 123456789import store from \"./store\"; //引入配置文件 new Vue({ el: \"#app\", router, store, //加载配置文件 components: { App }, template: \"&lt;App/&gt;\"}); 在子组件中使用 123456789101112131415161718192021222324252627282930313233&lt;template&gt; &lt;div&gt; &lt;div&gt;计数器：{{count}}&lt;/div&gt; &lt;p&gt; &lt;button @click=\"increment\"&gt;+&lt;/button&gt; &lt;button @click=\"decrement\"&gt;-&lt;/button&gt; &lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { name: \"UserList\", computed: { count() { //this.$store获取状态数据 return this.$store.state.count; } }, methods: { increment() { //this.$store.commit(\"methodName\")触发状态数据变更 this.$store.commit(\"increment\"); },decrement() { //this.$store.commit(\"methodName\")触发状态数据变更 this.$store.commit(\"decrement\"); } }};&lt;/script&gt; &lt;style scoped&gt;&lt;/style&gt; 核心概念State单一状态树，用来保存全部状态 12345678910111213141516171819202122232425262728src/store/index.js-&gt;保存状态 state: { count: 0, userInfo: { userName: \"harvie\", userPassword: \"wade777\", userHobby: [\"Basketball\", \"Football\", \"Game\"], userFriend: { userName: \"ryan\", userHobby: [\"Basketball\", \"Football\", \"Game\"] } } }子组件获取(计算属性)import { mapState } from \"vuex\";...computed: { //计算属性直接获取 count() { return this.$store.state.count; }, //mapState插件快速获取 ...mapState({ userInfoFromSate: \"userInfo\", userNameFromState: state =&gt; state.userInfo.userName })} Getter状态的计算属性 1234567891011121314151617181920212223src/store/index.js state: { todos: [\"Basketball\", \"Football\", \"Game\", \"Program\"] }, getters: { todosOutSite: state =&gt; { return state.todos.filter(todo =&gt; todo.length &gt; 4); }, todosCount: state =&gt; { return state.todos.length; } }子组件使用import { mapGetters } from \"vuex\";...computed: { //获取store.getter状态计算属性 ...mapGetters({ todosOutSite: \"todosOutSite\", todosCount: \"todosCount\" })} Mutation更改state的方法，类似事件，可提交对象，需要遵循Vue的响应规则(初始化所需属性/对象添加新属性要使用Vue.set()方法)，必须是同步函数 12345678910111213141516171819202122src/store/index.jsstate: { userInfo: { userName: \"harvie\", userPassword: \"wade777\" }},mutations: { changeUserNameAndPassword(state, playload) { state.userInfo.userName = playload.userName; state.userInfo.userPassword = playload.userPassword; Vue.set(state.userInfo, \"userNameBak\", playload.userName); }}子组件使用onSubmit() { this.$store.commit(\"changeUserNameAndPassword\", { userName: this.form.name, userPassword: this.form.password });} Action可执行异步操作、分发(调用)多重mutation、并且action可以相互组合使用(Promise保证组合action的调用顺序) 12345678910111213141516171819202122232425262728src/store/index.jsactions: { //异步action actionA(context, playload) { //Promise保证异步操作完成后可回调 return new Promise((resolve, reject) =&gt; { //执行耗时的异步操作 setTimeout(() =&gt; { console.log(\"执行increment\"); context.commit(\"increment\", playload); resolve(); //回调函数 }, 5000); }); }, //组合action：actionA-&gt;actionB actionB(context, playload) { //Promise保证异步actionA-&gt;actionB的执行顺序 return context.dispatch(\"actionA\", playload).then(() =&gt; { console.log(\"执行decrement\"); context.commit(\"decrement\"); }); }}子组件使用countAction() { this.$store.dispatch(\"actionB\", { n: 100 });} Module单一状态树下所有状态集中在一个store对象比较复杂臃肿，因此可以将store分割成module，每个module拥有自己的state/mutation/action/getter/module 划分模块并引入 12345678910111213141516src/store/module/moduleName.jsexport default { state: {}, getters: {}, mutations: {}, actions: {}}src/store/index.jsimport PersonModule from \"./module/PersonModule\"; const store = new Vuex.Store({ modules: { person: PersonModule }}); 子组件调用模块：模块内部的state默认是局部的属于模块本身，但是模块内部的getters/mutations/actions默认是注册在全局命名空间的，因此子组件可以直接对名称相同的mutation/action进行同步调用，但是子组件调用state需要指定模块名称 123456789101112131415161718192021222324252627282930313233343536子组件调用state需要指明moduleNamecomputed: { count() { return this.$store.state.person.count; }, personName() { return this.$store.state.person.userInfo.userName; }, animalName() { return this.$store.state.animal.animalName; }, //mapState插件快速获取 ...mapState({ userInfoFromSate: state =&gt; state.person.userInfo, userNameFromState: state =&gt; state.person.userInfo.userName })}子组件调用getter/mutations/actions直接调用computed: { //调用getters ...mapGetters({ todosOutSite: \"todosOutSite\", todosCount: \"todosCount\" })},methods: { //调用mutations increment() { this.$store.commit(\"increment\", { n: 1 }); }, //调用actions countAction() { this.$store.dispatch(\"actionB\", { n: 100 }); }} 模块调用模块：由于模块内部state是局部的，getters(state,getters,rootState)/actions(state,commit,rootState)可以通过显示指定rootState参数访问根节点的state 命名空间：模块可以通过添加namespaced使其getter/action/mutation自动根据模块注册的路径调整命名 123456789101112131415161718192021222324模块开启命名空间export default { namespaced: true, // ...}子组件调用加上/模块名前缀computed: { //调用getters ...mapGetters({ todosOutSite: \"person/todosOutSite\", todosCount: \"person/todosCount\" })},methods: { //调用mutations increment() { this.$store.commit(\"person/increment\", { n: 1 }); }, //调用actions countAction() { this.$store.dispatch(\"person/actionB\", { n: 100 }); }} 命名空间的模块的action的全局注册与分发 12345678910111213141516171819action分发全局action/mutation：添加参数{root:true}export default { namespaced: true, // ... actions: { callAction(context,playload) { context.commit(\"mutationName\", playload, {root: true}); context.dispatch(\"actionName\",playload, {root: true}); } }}action注册全局：添加root:true并用handle方法处理逻辑actions: { actionName: { root: true, handler(namespacedContext, payload) {} // -&gt; 'someAction' }}","link":"/2019/09/23/vue4/"}],"tags":[{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"前端","slug":"前端","link":"/tags/前端/"}],"categories":[]}