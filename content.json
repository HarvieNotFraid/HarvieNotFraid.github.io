{"pages":[],"posts":[{"title":"设计模式（二）UML统一建模语言：可视化设计","text":"类图Class-类 类名：类的唯一标识 属性(成员变量)：[可见性]属性名:类型[=默认值] 可见性：public(+)/private(-)/protected(#)/friendly(~) 操作(成员方法)：[可见性]名称(参数列表)[:返回类型] Interface-接口包含抽象操作但不包含属性，不可被实例化只能被子类实现 关系图Dependency-依赖关系一个类的方法通过局部变量、参数或静态方法调用另一个类中的方法 表示：带箭头的虚线，指向被依赖的类 Association-关联关系一个类的成员变量是另一个类的对象，有单向、双向关联 表示：带箭头的实线或没有箭头的实线 Aggregation-聚合关系是强的一种关联关系，整体和部分，has-a的关系，一个类的成员对象是整体对象的一部分，但成员对象可以脱离整体对象而独立存在 表示：空心菱形实线，菱形指向整体对象 Composition-组合关系是强的一种聚合关系，整体和部分，contains-a的关系，一个类的成员对象是整体对象的一部分，但成员对象不能脱离整体对象而存在 表示：实心菱形实线，菱形指向整体对象 Generalization-泛化关系耦合度最大的关系，一般和特殊，父类和子类，is-a的关系，一个类(子类)继承了另一个类(父类) 表示：空心三角箭头实线，箭头从子类指向父类 Realization-实现关系接口和实现类之间的关系，实现类实现了接口中声明的所有抽象操作 表示：空心三角箭头虚线，箭头从实现类指向接口 总结","link":"/2019/10/08/designPattern2-UML/"},{"title":"设计模式（一）概述","text":"基本要素 PatternName-名称：有助于理解、记忆、讨论该设计模式 Problem-问题：描述应用设计模式的环境 Solution-解决方案：描述设计模式的组成成分、相互关系、职责与协作方式 Consequence-效果：描述设计模式的应用效果和性能需求，包括时间、空间、灵活性、拓展性等问题 分类功能分类 创建型：如何创建对象，将对象的创建和使用分离 结构型：如何将类/对象按照布局组成更大的结构 行为型：类/对象之间如何相互写作完成大型任务，以及如何配分职责 范围分类 类模式：用于处理类与子类的关系，继承实现，静态关系 对象模式：用于处理对象与对象的关系，组合/聚合实现，动态关系 分类图 概述创建型模式 Factory Method-工厂方法 定义一个用于创建产品的接口，由子类决定生产什么产品 Singleton-单例 某类只能生成一个实例，并提供一个全局访问点供外部获取该实例，可拓展成有限多例模式 Prototype-原型 以一个对象为原型通过克隆复制出多个新实例 Abstract Factory-抽象工厂 提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品 Builder-建造者 将一个复杂对象分解成多个简单部分，根据不同需要分别创建，最后构成复杂对象 结构型模式 Adapter-适配器 将一个类的接口转换成客户希望的另一个接口，使得多个类可以通过该接口兼容工作 Proxy-代理 为对象提供代理，从而限制、增强或修改该对象的一些特性 Bridge-桥接 用组合代替继承关系分离抽象和实现，降低耦合度 Decorator-装饰 动态给对象增加额外的功能 Facade-外观 为多个复杂子系统提供一个一致的接口便于访问 Flyweight-享元 共享技术支持大量细粒度对象的复用 Composite-组合 将对象组合成树状结构，使用户对单个对象和组合对象具有一致的访问性 行为型模式 Template Method-模板方法 定义一个操作中的算法框架而特定步骤的实现放在子类实现 Interpreter-解释器 提供如何定义语言的文法和对语言句子解释的方法 Strategy-策略 封装一系列算法，并定义统一的算法接口使它们相互替换不会影响到使用算法的客户 Command-命令 将请求封装成对象，使发出请求和执行请求的职责分割 Chain of Responsibility-职责链 将请求在对象中链式传播直到被响应，降低对象之间的耦合 State-状态 对象在内部状态改变时会相应改变行为能力 Observer-观察者 在一对多的对象间，当一个对象发生改变会通知并影响到其他对象行为 Mediator-中介者 定义对象之间的中介对象简化交互过程，降低对象间的耦合度 Iterator-迭代器 提供一种顺序访问聚合对象数据的方法而不暴露对象的内部表示 Visitor-访问者 不改变集合元素的情况下，为一个集合中的每个元素提供多种访问方式 Memento-备忘录 不破坏封装的情况下，获取并保存一个对象的内部状态并可恢复 设计原则提高系统的可维护性、可拓展性、可复用性，增加开发效率 (Open Closed Principle,OCP)-开闭原则 软件实体应当对拓展开放，对修改关闭 (Liskov Substitution Principle,LSP)-里氏替换原则 继承必须确保超类所拥有的性质在子类仍然成立 核心：子类可以拓展父类的功能，但尽量不要改变(重写)父类的方法 (Dependence Inversion Principle,DIP)-依赖倒置原则 高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象 核心：面向接口编程替代面向实现编程，降低类间的耦合度 (Single Responsibility Principle,SRP)-单一职责原则 一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分 核心：控制类的粒度大小、将对象解耦、提高其内聚性 (Interface Segregation Principle,ISP)-接口隔离原则 客户端不应该被迫依赖于它不使用的方法，一个类对另一个类的依赖应该建立在最小的接口上 核心：接口尽量小，一个接口只有一个职责，降低类对接口的依赖性 (Law of Demeter,LoD)-迪米特法则(最少知识原则) 如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用 核心：对象除了访问成员对象、创建的对象、方法参数的对象外，不直接访问其他对象 (Composite Reuse Principle,CRP)-合成复用原则 软件复用时，组合/聚合等关联关系&gt;继承关系 核心：通过将对象声明成成员对象进行调用其功能达到复用","link":"/2019/10/08/designPattern1-概述/"},{"title":"设计模式（三）创建型模式","text":"设计模式分类图 Factory Method-工厂方法问题用户使用对象并不需要在意对象的生产细节 解决方案定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中 结构图 主要角色 Abstract Factory-抽象工厂：接口，定义创建产品的方法，调用者通过其方法访问具体工厂创建产品 Concrete Factory-具体工厂：类，实现抽象工厂接口，完成具体产品的创建 Abstract Product-抽象产品：接口，定义产品的规范，如产品特性和功能 Concrete Factory-具体产品：类，实现抽象产品接口，与具体工厂对应，由具体工厂创建 效果 优点 用户不需要在意对象的创建细节(类名、创建参数等)，只需要在意所需产品对应的具体工厂即可 开闭原则：系统加入新产品不需要修改现有的抽象类和实现类，只需要增加实现对应抽象类的具体工厂类和产品类即可 缺点 类数较多，增加系统的复杂度 Abstract Factory-抽象工厂问题工厂方法只能生产一类产品，不能生产一族产品 解决方案定义一个创建多种产品对象的工厂接口 结构图 效果 优点 客户端不依赖产品实例的创建细节和内部结构 可用于创建不同场景的对象，如不同操作系统的视窗构件(Button和Text构件在Windows和Linux中的实现不同) 缺点 产品族增加一个种类产品时，所有工厂类需要进行修改，不满足开闭原则 Singleton-单例问题某些类对象多次创建浪费系统资源、数据内容难以保持一致(成员属性值遗失) 解决方案保证单例类只有一个实例对象，该对象由单例类创建，并对外提供一个访问该对象的全局访问点 结构图 主要特点 构造函数私有化 存在静态全局访问实例对象方法 实现方式 懒汉式：类加载时没有生成单例，第一次调用getInstance()时才创建单例 Instance实例需要添加volatile关键字保证线程同步 getInstance()方法需要添加synchronized保证线程安全 饿汉式：类加载时就创建一个单例，线程安全 Instance=new Singleton() Instance前添加final关键字保证初始化后常量不变 效果 优点 节约系统资源，严格控制用户访问实例，实例数据一致 缺点 无抽象层，单例类较难拓展 垃圾回收机制重新实例化单例类则会遗失先前持有数据 Prototype-原型问题需要创建大量相同/相似的对象，构造函数创建较为繁琐并且浪费资源 解决方案将一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象 结构图 实现方式 Java对象的克隆：Java中的Object类提供的clone()方法，原型类需要实现Cloneable接口覆盖基类的clone()方法 implements Cloneable Objetc clone() throws CloneNotSupportedException{return (Realizetype)super.clone();} 浅克隆：克隆对象的基本数据类型的变量都会重新创建，而引用类型指向的还是原对象所指向的 深克隆：克隆对象基本数据类型还有引用类型，都是重新创建的 覆盖的clone()方法内除了调用基类的colne()方法克隆自身，克隆出的新对象还需要调用引用对象的clone()赋值给自身的成员引用对象 拓展 由于克隆对象可能成员方法的实现细节与原对象可能不同，因此可以增加原型管理器PrototypeManager 来保存多种实现同一接口的不同成员方法的克隆原型 效果 优点 简化对象创建过程，对于层级复杂、属性较多的对象可以提高对象生成效率 缺点 对象包含的所有对象都需要实现克隆方法，增加代码量，增加系统复杂度 Builder-建造者问题创建复杂对象的各个部分频繁变化，但复杂对象的组成部分是不变的 解决方案将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，即将产品不变的部分(产品的构造)和变化的部分(产品的组成部分)分离 结构图 构件流程 建造者Builder：选择具体建造者创造，具体建造者决定复杂对象的细节组成部分 指挥者Director：通过Builder创建指挥者，用于Product的构建(new)与组装(set) 复杂对象Product：通过Director.construct()生产得到产品 拓展 如果创建的产品种类只有一种，只需要一个具体的建造者，可以省略抽象建造者和指挥者角色，简化系统 效果 优点 用户不需要知道产品内部组成细节，使用相同的创建过程可创建不同部件的复杂对象 每个建造者相对独立，增加新的创建者无需修改原有代码，符合开闭原则 可以更加精细控制产品构建过程(Builder)，将复杂产品的构建分解在不同的方法中 缺点 复杂对象的组成部分必须相同，使用范围有限制 产品的内部变化复杂，会增加很多的建造者类，增加系统复杂度","link":"/2019/10/09/designPattern3-创建型模式/"},{"title":"设计模式（五）行为型模式","text":"设计模式分类图 Template Method-模板方法问题一个系统的某些步骤是固定的，另一些步骤的实现与具体的环境相关 解决方案定义一个操作中算法的框架，而将一些特定步骤的实现延迟到子类中 结构图 主要角色 AbstractClass-模板类：定义了固定步骤的模板方法和特定步骤的基本方法 ConcreteClass-具体子类：实现特定步骤的基本方法 拓展 模板类中的基本方法包括三大方法 抽象方法：特定子类实现的方法 具体方法：模板类实现的固定方法，子类可以继承或覆盖 钩子方法：子类可以重写达到控制父类行为的方法 效果 优点 封装了算法不变部分，拓展了算法可变部分，符合开闭原则 使用继承模板类的方式实现代码复用 缺点 每个基本方法的不同实现需要编写一个子类继承，若父类中的可变基本方法过多，会增加系统的复杂性 Interpreter-解释器问题多次重复出现的问题有一定的相似性和规律性 解决方案将问题归纳定义成一个语言的文法，并且建立一个解释器来解释该语言中的句子 结构图 主要角色 Abstract Expression-抽象表达式接口：定义解释器的解释行为 Terminal Expression-终结表达式：实现文法中与终结符有关的操作，每个终结符都对应一个具体的终结表达式 Nonterminal Expression-非终结表达式： 实现文法中与非终结符有关的操作，每条规则都对应一个具体的非终结表达式 Context-环境：包含解释器需要的数据或者公共的功能 效果 优点 易于通过继承等机制改变和拓展文法，符合开闭原则 缺点 复杂文法难以维护，执行效率低 Strategy-策略问题实现某种目标根据情况有多种方法可以选择 解决方案定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户 结构图 主要角色 Strategy-策略接口：公共接口，不同的算法以不同的方式实现这个接口 Concrete Strategy-具体策略：实现策略接口 Context-环境类：持有策略类引用，提供给客户端调用 拓展 存在很多策略时，可以通过策略工厂类管理同时管理多个策略 效果 优点 将选择使用哪种算法(环境类)的职责与算法实现(具体策略类)的职责分离开，符合单一职责原则 用户可以在不修改在原有系统基础上(客户端代码和环境类代码)选择或新增算法，符合开闭原则 缺点 客户端必须理解所有策略算法的区别，以便在恰当时机选择恰当的具体策略类 具体策略类过多，任何细小的变化都导致要新增一个策略类，提升系统复杂度 Command-命令问题方法请求者和方法实现者耦合度太高 解决方案将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开 结构图 拓展 可撤销(Undo)/可恢复(Redo)命令 命令模式+备忘录模式，可将命令对象存储起来 宏命令模式 命令模式+组合模式，宏命令包含一簇命令，执行时将递归调用所包含的所有命令 效果 优点 请求调用者与请求接收者解耦，通过命令类进行交互 随机请求/增加/删除命令类较方便实现，符合开闭原则 缺点 大量具体命令类增加系统复杂度 Chain of Responsibility-职责链问题一个请求有多个对象可以处理，但每个对象的处理条件或者权限不同，增加了处理难度 解决方案避免请求发送者与多个请求处理者耦合在一起，将多个请求处理者通过后者引用的方式传递请求，直到正确的请求处理者处理完成。 结构图 链表的实现方法 拓展 纯职责链 一个请求必须被某一个处理者处理完成 不纯的职责链 一个处理者可以处理请求的部分责任后将剩余的责任传递给下一个处理者，并且一个请求可以最终不被任何处理者处理 效果 优点 一个请求可以动态地由多个处理者处理，并且客户端不需要明确指定具体的请求处理者 不改变原有系统情况下可以添加新的处理者，符合开闭原则 每个处理者只需要负责自己的职责，符合单一职责原则 缺点 不能保证每个请求一定被处理 客户端需要建立职责链，需要保证职责链不循环调用性，增加客户端的复杂度 较长的职责链，请求处理设计多个对象，降低系统性能 State-状态问题一个对象的行为取决与它的状态(情况)，且其在运行时会根据状态改变行为 解决方案对有状态的对象，把状态变化对应的行为的复杂判断逻辑提取到不同的状态对象中 结构图 核心思想 Context调用方法是自身持有的具体State引用实例中的方法 拓展 共享状态 多个环境对象需要共享一组状态，则可以状态模式+享元模式 效果 优点 状态与行为分离，满足单一职责原则 程序容易拓展新的状态和转换，符合开闭原则 状态可以控制自身转化，对于具备复杂状态的对象有利于控制其行为过程 缺点 将状态抽象成类，增加系统复杂度 Observer-观察者问题一个对象的行为/状态发生改变会导致一个/多个其他对象的行为/状态发生改变 解决方案定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新，又称为发布-订阅(Publish-Subscribe)模式 结构图 核心思想 ConcreteSubject类通过notifyObserver方法通知所有ConcreteObserver调用自身的response方法更新自身的状态 拓展 Java实现 java.util.Observable：对应Subject类，用Vector向量用于保存要通知的观察者对象 java.util.Observer：对应Observer接口，其update方法用于更新自身状态 效果 优点 在目标与观察者之间建立一个抽象的耦合关系，降低系统耦合度 增加新的目标/观察者无需修改原有系统代码，目标与观察者之间不存在关联关系，符合开闭原则 缺点 目标与观察者之间的依赖关系没有完全接触，可能存在循环调用 观察者过多的情况下，通知机制影响程序效率 Mediator-中介者问题对象之间存在网状交互结构，耦合度很高，一个对象的行为会影响到所有关联的对象 解决方案定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互 结构图 核心思想 Colleague通过send发送请求需要调用其关联的中介者mediator.relay(this)将请求转发给除了自己的其他Colleague类(调用其receive方法接受请求) 拓展 单例中介者 不定义中介者接口，将具体中介对象实现为单例 Colleague类不持有中介者实例，而是在需要时直接通过Mediator.getMedium()获取调用 效果 优点 将对象一对多的关联关系转变为一对一的关系，降低对象耦合性，易于维护和拓展 缺点 Mediator包含大量不同Colleague的交互细节，可能导致Mediator的relay方法非常复杂难以维护 Iterator-迭代器问题遍历聚合对象中的所有元素，想分离聚合对象的创建和遍历过程，不暴露聚合对象的内部表示 解决方案提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示 结构图 核心思想 ConcreteAggregate调用getIterator时通过传入ConcreteAggregate.list来实例化ConcreteIterator迭代器 效果 优点 访问聚合对象无需暴露其内部组成 存储数据与遍历数据的职责分离，降低系统耦合度 支持自定义具体迭代器的遍历方式 面向接口编程，增加新的聚合类/迭代器类无需修改原有代码，符合封闭原则 遍历不同的聚合类提供统一的接口，封装性良好 缺点 设计易拓展、满足所有聚合类使用条件的迭代器难度较大 Visitor-访问者问题集合对象中存在多种不同的元素，每种元素根据访问者不同存在多种访问方式 解决方案将数据结构中的元素对象和元素操作分离封装成单独类，不改变数据结构的前提下为元素对象提供多种访问方式 结构图 核心思想 ObjectStructure持有包含元素的容器并提供访问元素的方式，Vistor接口申明访问每个具体元素的访问方法，Element接口申明访问者访问元素的方法 拓展 访问者+迭代器模式 ObjectStructure可以实现迭代器接口，使用迭代器遍历自身容器持有的元素 访问者+组合模式 元素对象如果包含组合对象，可以使用组合模式 效果 优点 增加新的访问操作即增加新的具体访问者，符合开闭原则 将有关元素对象的访问集中在一个访问者对象中，符合单一职责原则 缺点 增加新的元素类需要修改每个具体访问者的相应具体操作，违背开闭原则 访问者依赖于具体类而不是抽象类，违背依赖倒置原则 访问者可以调用每一个元素的操作，违背元素的封装性(迭代器模式可改善) Memento-备忘录问题用户误操作一个对象，想要撤销操作 解决方案不破坏封装性前提下，捕获对象的内部状态保存至对象外部，之后在需要时可以将对象恢复至原先保存的状态，也称作快照模式 结构图 主要角色 Originator-发起人：用于存储当前时刻对象的状态，提供createMemento(创建备忘录)和restoreMemento(恢复备忘录数据)的功能 Memento-备忘录：负责存储Originator的内部状态，在需要时将存储的内部状态提供给Originator Caretaker-管理员：对Memento进行管理，提供Memento的get/set方法 核心思想 Originator需要保存状态的时候调用Caretaker.setMemento(Originator.createMemento())，需要恢复状态的时候调用Originator.restoreMemento(Caretaker.getMemento()) 拓展 多状态备份 备忘录模式+原型模式，让Originator实现Cloneable接口可以自我备份，这样就可以删除备忘录 效果 优点 提供一种可恢复的机制，当用户需要时能够比较方便地将数据恢复到历史版本状态 发起人类不持有备忘录，所有信息保存在备忘录中由管理者进行管理，符合单一职责原则 缺点 资源消耗大，内部状态信息过多或者频繁快照会占用过多系统资源","link":"/2019/10/09/designPattern5-行为型模式/"},{"title":"设计模式（四）结构型模式","text":"设计模式分类图 Adapter-适配器问题某种具备业务功能的类/对象已经存在，但是与当前系统的接口规范不兼容 解决方案将类的接口转换成另外一个可以兼容当前系统的接口 结构图 类适配器 对象适配器 主要角色 Adaptee-适配者：与当前系统不兼容的类 ObjectAdapter-适配器：转换器，将当前系统不兼容的类转换成可以兼容当前系统的接口 Target-目标接口：能与当前系统兼容的接口 实现方式 类适配器：将一个类转换成另一个新接口类 C++：多重继承，ObjectAdapter同时继承Adaptee和Target接口 Java：继承+实现，ObjectAdapter继承Adaptee同时实现Target接口 对象适配器：将一个对象转换成另一个新接口类的对象 ObjectAdapter持有Adaptee实例，实现Target接口方法内对Adaptee实例的方法进行改进 效果 优点 适配器类不改变原有的类，符合开闭原则 目标类和现有类解耦，提高程序拓展性 缺点 类适配器更换实现的过程较为复杂，增加系统复杂度 Proxy-代理问题由于性能、安全等原因不能直接访问目标对象 解决方案为某个对象提供一个代理，并由这个代理对象控制对原对象的访问 结构图 主要角色 Subject-主题：真实主题中需要代理的方法 RealSubject-真实主题：被代理的对象，实现具体业务逻辑 Proxy-代理：可以访问、拓展、控制真实主题的方法，提供代理后的与真实主题相同接口的方法 实现 RealSubject和Proxy均实现同一Subject接口类的方法 Proxy内部含有RealSubject的对象引用 拓展 普通代理模式的实现缺点 一个目标对象需要一个自身的代理，不灵活 目标对象存在代理才可以存在，不灵活 动态代理：代理逻辑与业务逻辑相互独立，不侵入(引用)，没有耦合 AOP：动态代理的最好诠释 效果 优点 代理能够分离调用者和被调用者，降低系统耦合度 多类型代理可以控制目标对象的访问 远程代理：保护、隐藏目标对象的地 虚拟代理：用代理代替复杂的目标对象计算，只有真正需要目标对象处理时才实例化，减少系统消耗 安全代理：控制不同种类用户对目标对象的访问权限 消息代理：消息队列 缺点 用户请求变慢，增加系统复杂度 Bridge-桥接问题多个类具备多个维度的变化，如用继承，则x种颜色类和y种字体类的文字有x*y个子类，繁多且难以拓展 解决方案将抽象与实现分离，使它们可以独立变化，组合代替继承的方法 结构图 核心思想 面向接口编程：Abstraction通过持有Implementor引用对象来实现RefinedAbstraction实体类与Implementor接口实现类的多种组合 效果 优点 拓展性好，无论有多少接口实现类，均可通过一个类实现组合 缺点 设计前需要识别出独立变化的维度，即抽离出接口类 Decorator-装饰问题一些类需要在不改变其核心功能的情况下动态拓展功能 解决方案不改变现有对象结构的情况下，动态地给该对象增加一些职责 结构图 主要角色 Component：接口，定义需要装饰的方法 Concrete Component：实现Component接口的类，装饰方法的核心实现 Decorator：实现Component接口的类，包含具体Component实例，通过其子类拓展装饰方法 Concrete Decorator：Decorator子类，实现装饰方法 经典案例 Java I/O标准库的设计 InputStream、OutputStream、Reader、Writer的子类都是抽象装饰类 拓展 单Concrete Component类 可不用Component接口，Decorator直接继承 单Concrete Decorator类 可将Decorator与Concrete Decorator合并 效果 优点 添加职责的类不能生成子类，则可以使用装饰模式 装饰类添加的功能可以动态添加(装饰)、撤销(不装饰) 缺点 具体装饰类会增加系统复杂度 Facade-外观问题系统功能增加，子系统越来越多，用户对系统的访问越来越复杂，这时系统内部改变客户端也要随之改变，违背了开闭原则 解决方案定义一个高层接口，为多个复杂的子系统提供一个统一的访问接口 结构图 核心思想 Facade持有多个子系统的实例，用户通过创建Facade实例、调用Facade方法达到调用多个子系统实例方法的效果 拓展 增加或者移除子系统需要修改外观类，违背开闭员原则，可以通过引入外观接口，实现多个具体外观类，每个具体外观类持有不同的子系统实例来解决这个问题 效果 优点 降低子系统与客户端之间的耦合度，简化客户端的调用过程，便于子系统的拓展和维护 符合迪米特法则：子系统只需要将外部调用接口暴露，隐藏内部方法 缺点 不引入外观接口的情况下，新增子系统需要修改外观类或客户端代码，不符合开闭原则 Flyweight-享元问题系统中需要创建或存在大量相同或相似对象实例，耗费系统资源，降低系统性能 解决方案运用共享技术复用大量细粒度的对象，即使用共享池相同的对象只需要保存一份，通常与工厂模式一起使用 结构图 主要角色 FlyweightFactory-享元工厂：创建和管理享元实例 Flyweight-享元接口：规范享元类实现的方法，非享元对象以参数方式传入 Concrete Flyweight-具体享元类：实现享元接口的方法 Unshared Concrete Flyweight-非享元类：不共享的外部状态 实例 JAVA中的JDBC连接池 getConnection方法返回连接池中的一个数据库连接(享元) 拓展 单纯享元模式 系统中不存在非享元类 复合享元模式 一些具体享元类持有单纯享元对象 效果 优点 减少内存中的重复对象，降低系统内存使用，提升系统性能 缺点 需要拆解对象为享元类和非享元类，提升系统复杂度，并且读取享元模式会使系统运行时间变长 Composite-组合问题对象之间存在部分-整体的关系，对这些简单对象与复合对象的处理较难 解决方案将对象组合成树状的层次结构，是用户对单个对象和组合对象有一致的访问性 结构图 透明结构 节点接口包含所有管理子节点方法(add/remove/getChild)，因此对于叶子节点类需要注意空指针等安全异常 安全结构 节点接口不包含管理子节点方法，因此客户端调用需要区分叶子节点和分支节点，失去封装性 效果 优点 客户端一致使用单个对象和组合对象，简化调用流程 更容易在组合对象中加入单个对象，符合开闭原则 缺点 设计复杂，类之间的层次关系较复杂 不容易使用继承来增加节点的新功能","link":"/2019/10/09/designPattern4-结构型模式/"},{"title":"Vue入门与实践(一) 概述","text":"Vue的架构设计MVVM(Model-View-ViewModel)：一种软件架构设计模式，思想是事件驱动编程，核心是通过ViewModel层向上与View层双向绑定、向下与Model层通过接口进行数据交互，实现View与Model层的解耦，而Vue.js就是MVVM中ViewModel层的实现者 通过Data Bindings观察Model中的数据变化并对View层对应数据进行更新 通过DOM Listeners监听View中的数据变化并通知Model层数据的改变 Vue.js的优点 轻量级、体积小，经过压缩后仅仅20+kb、 吸取了Angular(模块化)和React(虚拟DOM)的优点，并拥有自己的独特功能(计算属性等) 学习曲线平稳，开源，社区活跃度高 Vue两大核心概念 数据驱动+虚拟DOM：Vue通过Object.defineProperty将普通JS对象属性转换成getter/setter，在被访问/修改时能通知(Notify)关联的组件实例的watch对象在虚拟DOM上更新组件数据，当所有更新操作完成后再一次性将虚拟DOM上的修改更新到真实DOM上 组件化：页面上每个独立可交互的区域都可以视为一个组件，通过组件的复用，增强页面的拓展性和可维护性 Vue实例的生命周期主要的八大时期 beforeCreate：实例创建前，即数据观测(Data Observer)和event/watch事件配置前 created：实例创建完成后，即数据观测(Data Observer)、属性和方法的运算和event/watch事件的回调后，挂载前($el属性不可见) beforeMount：实例挂载前，相关的render函数被调用 mouted：实例挂载后调用 beforeUpdate：数据更新前调用，在虚拟DOM重新渲染和打补丁前 updated：数据更新后调用，虚拟DOM重新渲染和打补丁后，此阶段禁止更新数据状态(可能造成循环更新) beforeDestroy：实例销毁前，此时实例仍然可用 destroyed：实例销毁后，Vue实例的事件监听器、子实例等所有被销毁 Webpack 本质上是JS程序的静态模块打包器(module bundler)，递归地将程序需要的模块打包成一个或多个bundle 简洁地说，是前端资源模块化管理和打包的工具 可以将松耦合的模块按照依赖和规则打包成符合生产环境部署的前端资源 可以将按需加载的模块进行代码分离，等到实际需要时再异步加载 可以通过loader转换，任何形式的资源都可以当作模块，如CommonsJS、AMD、ES6、CSS、JSON、CoffeeScript、LESS等 JS模块管理规范：见JS模块化的演进","link":"/2019/09/23/vue1-概述/"},{"title":"Vue入门与实践(二) Vue核心概念与官方脚手架介绍","text":"Vue组件的三大核心 computed-计算属性：用于将不经常变化的计算结果进行缓存，不像调用方法每次都要进行计算，计算属性只有关联的属性值变化且自身被调用时才进行计算，节约系统开销 slot-插槽：用于组件组合场景进行内容分发，父组件可以通过具名插槽分发数据给子组件不同的插槽，子组件也可以通过作用域插槽分发数据给父组件的插槽 methods-自定义事件：子组件可以通过自定义事件更改父组件中的Vue实例的数据，通过方法中执行this.$emit(“父组件方法名”,传递的参数)调用父组件中的方法更改Vue实例的数据 Vue-cliVue官方脚手架，用于快速生成vue项目模板 主要功能：统一目录结构，本地调试，热部署，单元测试，集成打包上线 项目目录结构 其中package.json中包含 scripts-封装vue常用命令 dependencies-生产环境依赖 devDependencies-开发环境依赖 src/main.js：项目入口文件 1234567891011//ES6写法，等同于require(\"vue\"),require是NodeJS提供的模块加载器import Vue from \"vue\";import App from \"./App\"; //上同，./表示当前目录 Vue.config.productionTip = false; //关闭浏览器关于环境的提示 new Vue({ el: \"#app\", //查找index.html中id为app的元素进行挂载 components: { App }, //声明引入组件App template: \"&lt;App/&gt;\" //模板，会将挂载元素替换为&lt;App/&gt;});","link":"/2019/09/23/vue2-CLI/"},{"title":"Vue入门与实践(四) Vuex","text":"核心思想集中式存储、管理应用的所有组件的状态(数据)，并以相应的规则保证状态以一种可预测的方式发生变化 在vue-cli中安装、配置与基本使用安装1npm install vuex --save 配置在src/store/index.js编写配置文件 12345678910111213141516171819import Vue from \"vue\";import Vuex from \"vuex\";Vue.use(Vuex); const store = new Vuex.Store({ //store.state获取状态 state: { count: 0 }, mutations: { //store.commit('increment')触发状态变更 increment(state) { state.count++; }, decrement: state =&gt; state.count-- }}); export default store; 在src/main.js入口文件中在App上加载配置文件 123456789import store from \"./store\"; //引入配置文件 new Vue({ el: \"#app\", router, store, //加载配置文件 components: { App }, template: \"&lt;App/&gt;\"}); 在子组件中使用 123456789101112131415161718192021222324252627282930313233&lt;template&gt; &lt;div&gt; &lt;div&gt;计数器：{{count}}&lt;/div&gt; &lt;p&gt; &lt;button @click=\"increment\"&gt;+&lt;/button&gt; &lt;button @click=\"decrement\"&gt;-&lt;/button&gt; &lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { name: \"UserList\", computed: { count() { //this.$store获取状态数据 return this.$store.state.count; } }, methods: { increment() { //this.$store.commit(\"methodName\")触发状态数据变更 this.$store.commit(\"increment\"); },decrement() { //this.$store.commit(\"methodName\")触发状态数据变更 this.$store.commit(\"decrement\"); } }};&lt;/script&gt; &lt;style scoped&gt;&lt;/style&gt; 核心概念State单一状态树，用来保存全部状态 12345678910111213141516171819202122232425262728src/store/index.js-&gt;保存状态 state: { count: 0, userInfo: { userName: \"harvie\", userPassword: \"wade777\", userHobby: [\"Basketball\", \"Football\", \"Game\"], userFriend: { userName: \"ryan\", userHobby: [\"Basketball\", \"Football\", \"Game\"] } } }子组件获取(计算属性)import { mapState } from \"vuex\";...computed: { //计算属性直接获取 count() { return this.$store.state.count; }, //mapState插件快速获取 ...mapState({ userInfoFromSate: \"userInfo\", userNameFromState: state =&gt; state.userInfo.userName })} Getter状态的计算属性 1234567891011121314151617181920212223src/store/index.js state: { todos: [\"Basketball\", \"Football\", \"Game\", \"Program\"] }, getters: { todosOutSite: state =&gt; { return state.todos.filter(todo =&gt; todo.length &gt; 4); }, todosCount: state =&gt; { return state.todos.length; } }子组件使用import { mapGetters } from \"vuex\";...computed: { //获取store.getter状态计算属性 ...mapGetters({ todosOutSite: \"todosOutSite\", todosCount: \"todosCount\" })} Mutation更改state的方法，类似事件，可提交对象，需要遵循Vue的响应规则(初始化所需属性/对象添加新属性要使用Vue.set()方法)，必须是同步函数 12345678910111213141516171819202122src/store/index.jsstate: { userInfo: { userName: \"harvie\", userPassword: \"wade777\" }},mutations: { changeUserNameAndPassword(state, playload) { state.userInfo.userName = playload.userName; state.userInfo.userPassword = playload.userPassword; Vue.set(state.userInfo, \"userNameBak\", playload.userName); }}子组件使用onSubmit() { this.$store.commit(\"changeUserNameAndPassword\", { userName: this.form.name, userPassword: this.form.password });} Action可执行异步操作、分发(调用)多重mutation、并且action可以相互组合使用(Promise保证组合action的调用顺序) 12345678910111213141516171819202122232425262728src/store/index.jsactions: { //异步action actionA(context, playload) { //Promise保证异步操作完成后可回调 return new Promise((resolve, reject) =&gt; { //执行耗时的异步操作 setTimeout(() =&gt; { console.log(\"执行increment\"); context.commit(\"increment\", playload); resolve(); //回调函数 }, 5000); }); }, //组合action：actionA-&gt;actionB actionB(context, playload) { //Promise保证异步actionA-&gt;actionB的执行顺序 return context.dispatch(\"actionA\", playload).then(() =&gt; { console.log(\"执行decrement\"); context.commit(\"decrement\"); }); }}子组件使用countAction() { this.$store.dispatch(\"actionB\", { n: 100 });} Module单一状态树下所有状态集中在一个store对象比较复杂臃肿，因此可以将store分割成module，每个module拥有自己的state/mutation/action/getter/module 划分模块并引入 12345678910111213141516src/store/module/moduleName.jsexport default { state: {}, getters: {}, mutations: {}, actions: {}}src/store/index.jsimport PersonModule from \"./module/PersonModule\"; const store = new Vuex.Store({ modules: { person: PersonModule }}); 子组件调用模块：模块内部的state默认是局部的属于模块本身，但是模块内部的getters/mutations/actions默认是注册在全局命名空间的，因此子组件可以直接对名称相同的mutation/action进行同步调用，但是子组件调用state需要指定模块名称 123456789101112131415161718192021222324252627282930313233343536子组件调用state需要指明moduleNamecomputed: { count() { return this.$store.state.person.count; }, personName() { return this.$store.state.person.userInfo.userName; }, animalName() { return this.$store.state.animal.animalName; }, //mapState插件快速获取 ...mapState({ userInfoFromSate: state =&gt; state.person.userInfo, userNameFromState: state =&gt; state.person.userInfo.userName })}子组件调用getter/mutations/actions直接调用computed: { //调用getters ...mapGetters({ todosOutSite: \"todosOutSite\", todosCount: \"todosCount\" })},methods: { //调用mutations increment() { this.$store.commit(\"increment\", { n: 1 }); }, //调用actions countAction() { this.$store.dispatch(\"actionB\", { n: 100 }); }} 模块调用模块：由于模块内部state是局部的，getters(state,getters,rootState)/actions(state,commit,rootState)可以通过显示指定rootState参数访问根节点的state 命名空间：模块可以通过添加namespaced使其getter/action/mutation自动根据模块注册的路径调整命名 123456789101112131415161718192021222324模块开启命名空间export default { namespaced: true, // ...}子组件调用加上/模块名前缀computed: { //调用getters ...mapGetters({ todosOutSite: \"person/todosOutSite\", todosCount: \"person/todosCount\" })},methods: { //调用mutations increment() { this.$store.commit(\"person/increment\", { n: 1 }); }, //调用actions countAction() { this.$store.dispatch(\"person/actionB\", { n: 100 }); }} 命名空间的模块的action的全局注册与分发 12345678910111213141516171819action分发全局action/mutation：添加参数{root:true}export default { namespaced: true, // ... actions: { callAction(context,playload) { context.commit(\"mutationName\", playload, {root: true}); context.dispatch(\"actionName\",playload, {root: true}); } }}action注册全局：添加root:true并用handle方法处理逻辑actions: { actionName: { root: true, handler(namespacedContext, payload) {} // -&gt; 'someAction' }}","link":"/2019/09/23/vue4-Vuex/"},{"title":"Vue入门与实践(三) Vue-Router","text":"主要功能嵌套的路由/试图表，模块化基于组件的路由配置，基于Vue.js过度系统的视图效果，细粒度的导航控制，自动激活的CSS class链接 使用流程安装在项目根目录下执行 1npm install vue-router --save-dev 编写路由配置文件在src/router下创建index.js文件存放路由配置 12345678910111213141516171819202122import Vue from 'vue'// 导入路由插件import Router from 'vue-router'// 导入定义的组件import Component from '@/components/Component' // 安装路由Vue.use(Router); // 配置路由export default new Router({ routes: [ { // 路由路径 path: '/component', // 路由名称 name: 'Component', // 跳转到组件 component: Component } ]}); 加载配置文件在main.js下引入路由配置目录 12345678910111213import Vue from 'vue'import App from './App'// 导入上面创建的路由配置目录import router from './router' Vue.config.productionTip = false; new Vue({ el: '#app', router, // 配置路由 components: { App }, template: '&lt;App/&gt;'}); 使用路由在需要跳转的界面使用路由跳转 12345678910111213141516171819202122&lt;template&gt; &lt;div id=\"app\"&gt; &lt;img src=\"./assets/logo.png\" /&gt; &lt;!-- router-link默认被渲染成&lt;a&gt;标签 用于跳转 --&gt; &lt;router-link to=\"/\"&gt;首页&lt;/router-link&gt; &lt;router-link to=\"/content\"&gt;内容&lt;/router-link&gt; &lt;!-- router-view用于渲染路由匹配到的组件 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;HelloWorld&gt;&lt;/HelloWorld&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;import Content from \"./components/Content\"; //引入路由匹配的组件 export default { name: \"App\", components: { Content //声明路由匹配的组件 }};&lt;/script&gt; 路由实战：登录页面创建项目1vue init webpack vue-login 安装、配置路由依赖见上部分 安装Element-ui依赖项目根目录Npm安装依赖包 1npm i element-ui -S 项目中引入Element：在入口文件main.js写入 123456//引入Element-ui依赖import ElementUI from \"element-ui\";import \"element-ui/lib/theme-chalk/index.css\"; //安装Element-ui依赖Vue.use(ElementUI); 创建src/views用于存放页面编写views/Main.vue：登录成功的跳转页面 123456789101112&lt;template&gt; &lt;div&gt;首页&lt;/div&gt;&lt;/template&gt; &lt;script&gt;export default { name: \"Main\"};&lt;/script&gt; &lt;style scoped&gt;&lt;/style&gt; 编写views/Login.vue：登录页面 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;template&gt; &lt;div&gt; &lt;el-form ref=\"loginForm\" :model=\"form\" :rules=\"rules\" label-width=\"80px\" class=\"login-box\"&gt; &lt;h3 class=\"login-title\"&gt;欢迎登录&lt;/h3&gt; &lt;el-form-item label=\"账号\" prop=\"username\"&gt; &lt;el-input type=\"text\" placeholder=\"请输入账号\" v-model=\"form.username\" /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=\"密码\" prop=\"password\"&gt; &lt;el-input type=\"password\" placeholder=\"请输入密码\" v-model=\"form.password\" /&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button type=\"primary\" v-on:click=\"onSubmit('loginForm')\"&gt;登录&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;el-dialog title=\"温馨提示\" :visible.sync=\"dialogVisible\" width=\"30%\"&gt; &lt;span&gt;请输入账号和密码&lt;/span&gt; &lt;span slot=\"footer\" class=\"dialog-footer\"&gt; &lt;el-button type=\"primary\" @click=\"dialogVisible = false\"&gt;确 定&lt;/el-button&gt; &lt;/span&gt; &lt;/el-dialog&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;export default { name: \"Login\", data() { return { form: { username: \"\", password: \"\" }, // 表单验证，需要在 el-form-item 元素中增加 prop 属性 rules: { username: [ { required: true, message: \"账号不可为空\", trigger: \"blur\" } ], password: [{ required: true, message: \"密码不可为空\", trigger: \"blur\" }] }, // 对话框显示和隐藏 dialogVisible: false }; }, methods: { onSubmit(formName) { // 为表单绑定验证功能 this.$refs[formName].validate(valid =&gt; { if (valid) { // 使用 vue-router 路由到指定页面，该方式称之为编程式导航 this.$router.push(\"/main\"); } else { this.dialogVisible = true; return false; } }); } }};&lt;/script&gt; &lt;style scoped&gt;.login-box { border: 1px solid #dcdfe6; width: 350px; margin: 180px auto; padding: 35px 35px 15px 35px; border-radius: 5px; -webkit-border-radius: 5px; -moz-border-radius: 5px; box-shadow: 0 0 25px #909399;} .login-title { text-align: center; margin: 0 auto 40px auto; color: #303133;}&lt;/style&gt; 编写router/index.js配置路由跳转信息123456789101112131415161718192021222324252627282930import Vue from \"vue\";import Router from \"vue-router\";import HelloWorld from \"@/components/HelloWorld\";//引入所用的页面组件import Login from \"@/views/Login\";import Main from \"@/views/Main\"; Vue.use(Router); export default new Router({ routes: [ { path: \"/\", name: \"HelloWorld\", component: HelloWorld }, { // 登录页 path: \"/login\", name: \"Login\", component: Login }, { // 首页 path: \"/main\", name: \"Main\", component: Main } ]}); 在项目根目录运行项目1npm run dev 打开http://localhost:8080/#/login 没有输入账号/密码点击登录会弹出提示框 输入账号密码点击登录即可进入首页(Main.vue) 路由实战：首页导航栏多页面嵌套路由(子路由)要实现首页多页面(选项卡)，需要保证整个页面(首页)是一个路由，然后点击不同的选项卡展示不同的内容，即在首页这个路由中嵌套不同内容页面的子路由 编写子路由展示的页面编写views/user/Profile.vue 123456789101112&lt;template&gt; &lt;div&gt;个人信息&lt;/div&gt;&lt;/template&gt; &lt;script&gt;export default { name: \"UserProfile\"};&lt;/script&gt; &lt;style scoped&gt;&lt;/style&gt; 编写views/user/List.vue 123456789101112&lt;template&gt; &lt;div&gt;用户列表&lt;/div&gt;&lt;/template&gt; &lt;script&gt;export default { name: \"UserList\"};&lt;/script&gt; &lt;style scoped&gt;&lt;/style&gt; 修改router/index.js配置嵌套路由路径12345678910111213141516171819//引入嵌套的路由组件import UserProfile from \"@/views/user/Profile\";import UserList from \"@/views/user/List\";export default new Router({ routes: [ { // 首页 path: \"/main\", name: \"Main\", component: Main, //配置嵌套路由 children: [ { path: \"/user/profile\", component: UserProfile }, { path: \"/user/list\", component: UserList } ] } ]}); 修改views/Main.vue采用Element-Container布局容器组件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;template&gt; &lt;div&gt; &lt;!-- 布局容器 --&gt; &lt;el-container&gt; &lt;!-- 侧边栏容器 --&gt; &lt;el-aside width=\"200px\"&gt; &lt;el-menu :default-openeds=\"['1','2']\"&gt; &lt;el-submenu index=\"1\"&gt; &lt;template slot=\"title\"&gt; &lt;i class=\"el-icon-message\"&gt;&lt;/i&gt;用户中心 &lt;/template&gt; &lt;el-menu-item-group&gt; &lt;el-menu-item index=\"1-1\"&gt; &lt;!-- 配置嵌套路由跳转 --&gt; &lt;router-link to=\"/user/profile\"&gt;个人信息&lt;/router-link&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index=\"1-2\"&gt;演示&lt;/el-menu-item&gt; &lt;el-menu-item index=\"1-3\"&gt;演示&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;/el-submenu&gt; &lt;el-submenu index=\"2\"&gt; &lt;template slot=\"title\"&gt; &lt;i class=\"el-icon-caret-right\"&gt;&lt;/i&gt;用户管理 &lt;/template&gt; &lt;el-menu-item-group&gt; &lt;el-menu-item index=\"2-1\"&gt; &lt;!-- 配置嵌套路由跳转 --&gt; &lt;router-link to=\"/user/list\"&gt;用户列表&lt;/router-link&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index=\"2-2\"&gt;演示&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;/el-submenu&gt; &lt;/el-menu&gt; &lt;/el-aside&gt; &lt;!-- 侧边栏容器右边的外层容器 --&gt; &lt;el-container&gt; &lt;!-- 顶栏容器 --&gt; &lt;el-header style=\"text-align: right; font-size: 12px\"&gt; &lt;el-dropdown&gt; &lt;i class=\"el-icon-setting\" style=\"margin-right: 15px\"&gt;&lt;/i&gt; &lt;el-dropdown-menu slot=\"dropdown\"&gt; &lt;el-dropdown-item&gt;个人信息&lt;/el-dropdown-item&gt; &lt;el-dropdown-item&gt;退出登录&lt;/el-dropdown-item&gt; &lt;/el-dropdown-menu&gt; &lt;/el-dropdown&gt; &lt;span&gt;Harvie&lt;/span&gt; &lt;/el-header&gt; &lt;!-- 主要区域容器 --&gt; &lt;el-main&gt; &lt;!-- 渲染嵌套路由跳转的页面展示 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/el-main&gt; &lt;/el-container&gt; &lt;/el-container&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;export default { name: \"Main\"};&lt;/script&gt; &lt;style scoped&gt;.el-header { background-color: #b3c0d1; color: #333; line-height: 60px;} .el-aside { color: #333;}&lt;/style&gt; 运行展示 路由传参路径参数：通过路径传递参数，参数的值可显示在路由路径上修改路由配置：增加占位符标识 12345{ path: \"/user/profile/:id\", name: \"UserProfile\", component: UserProfile}, 传递参数：有两种方式 声明式导航：&lt;router-link&gt; 1&lt;router-link :to=\"{name:'UserProfile',params:{id:this.id}}\"&gt;声明式导航：个人信息&lt;/router-link&gt; 编程式导航：this.$router.push(path) 12345678&lt;el-menu-item index=\"1-2\" @click=\"userProfileClick\"&gt;编程式导航：个人信息&lt;/el-menu-item&gt;userProfileClick: function() { const id = this.$data.id; this.$router.push({ path: `/user/profile/${id}` });} 组件接收参数：$route.params.paramName 1this.$route.params.id 属性(Props)参数：通过props传递参数修改路由配置：添加开启props属性 123456{ path: \"/user/list\", name: \"UserList\", component: UserList, props: true} 传递参数：可传复杂对象 数据对象 12345678910111213data() { return { userInfo: { userName: \"harvie\", userPassword: \"wade777\", userHobby: [\"Basketball\", \"Football\", \"Game\"], userFriend: { userName: \"ryan\", userHobby: [\"Basketball\", \"Football\", \"Game\"] } } };} 声明式导航：&lt;router-link&gt; 1&lt;router-link :to=\"{name:'UserList',params:{userInfo:this.userInfo}}\"&gt;声明式导航：用户列表&lt;/router-link&gt; 编程式导航：this.$router.push(name,params) 12345678910&lt;el-menu-item index=\"2-2\" @click=\"userListClick\"&gt;编程式导航：用户列表&lt;/el-menu-item&gt;userListClick: function() { this.$router.push({ name: \"UserList\", params: { userInfo: this.$data.userInfo } });} 组件接收参数 12345props: { userInfo: { type: Object }} 重定向路由组件路由路径不同但是调用的组件相同 12345678src/router/index.js{ path: \"/goLogin\", redirect:\"/login\"}src/views/Main.vue&lt;router-link to=\"/goLogin\"&gt;回到登录&lt;/router-link&gt; 路由路径模式 hash：路径带#符号 history：路径不带#符号 配置方式 12345export default new Router({ mode: 'history', routes: [ ]}); 404-空页面路由配置路由1234567891011import NotFound from \"@/views/NotFound\"; export default new Router({ routes: [ //404页面 { path: \"*\", component: NotFound } ]}); 配置页面123456789101112&lt;template&gt; &lt;div&gt;页面不存在，请重试！&lt;/div&gt;&lt;/template&gt; &lt;script&gt;export default { name: \"NotFount\"};&lt;/script&gt; &lt;style scoped&gt;&lt;/style&gt; 路由钩子函数组件内的钩子函数beforeRouteEnter：导航进入路由对应的组件前调用，实例还没创建，不能使用this获取组件实例 beforeRouteUpdate：路由改变但是对应的组件被复用(如/user/1-&gt;/user/2)时被调用 beforeRouteLeave：导航离开组件的路由时被调用 参数(to,from,next) to：导航进入的路由的路径信息 from：导航离开的路由的路径信息 next：路由的控制参数 next()：进入下个页面 next(‘/path’)：改变路由跳转方向 next(false)：返回原来的路由 next((vm)=&gt;{})：beforeRouteEnter中获取访问组件实例(vm)的回调函数，在导航被确认时执行回调 实例1234567891011121314151617181920212223beforeRouteEnter: (to, from, next) =&gt; { next(vm =&gt; { // 通过 `vm` 访问组件实例 vm.getDate(); });},beforeRouteUpdate(to, from, next) { console.log(\"复用组件,to.params.id：\" + to.params.id); console.log(\"复用组件,from.params.id：\" + from.params.id); //这里的this是更新前的组件 console.log(\"复用组件,this.id：\" + this.id); next();},beforeRouteLeave(to, from, next) { const answer = window.confirm( \"Do you really want to leave? you have unsaved changes!\" ); if (answer) { next(); } else { next(false); }}","link":"/2019/09/23/vue3-VueRouter/"}],"tags":[{"name":"设计模式","slug":"设计模式","link":"/tags/设计模式/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"前端","slug":"前端","link":"/tags/前端/"}],"categories":[]}